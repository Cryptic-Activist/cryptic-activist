// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
  // output   = "node_modules/@prisma/client"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model AcceptedCryptocurrency {
  id          String @id @default(uuid())
  coingeckoId String @unique @db.VarChar(200)
  symbol      String @db.VarChar(200)
  name        String @db.VarChar(200)

  @@map("accepted_cryptocurrencies")
}

model AdminAdminRole {
  admin        Admin      @relation(fields: [adminId], references: [id], onDelete: Restrict, onUpdate: Cascade)
  adminId      String
  adminRoles   AdminRoles @relation(fields: [adminRolesId], references: [id])
  adminRolesId String

  @@id([adminId, adminRolesId])
  @@map("admin_admin_role")
}

enum AdminRole {
  SUPER_ADMIN // Full access: user management, trades, disputes, KYC, settings
  SENIOR_ADMIN // Handles escalated cases and oversees other admins
  MODERATOR // Can manage trades, disputes, and users (limited control)
  KYC_REVIEWER // Only reviews and approves/rejects KYC documents
  DISPUTE_MANAGER // Handles only dispute resolution between traders
  SUPPORT_AGENT // Can respond to support queries, chat moderation
  AUDITOR // Read-only access to logs, trades, feedback, for auditing
  FINANCE_MANAGER // Views and manages fiat/crypto flow stats, premium purchases
}

model AdminRoles {
  id             String           @id @default(uuid())
  role           AdminRole
  adminAdminRole AdminAdminRole[]

  // @@unique([adminId, role]) // Prevent duplicate roles per admin
  @@map("admin_roles")
}

model Admin {
  id                     String                   @id @default(uuid())
  firstName              String                   @db.VarChar(50)
  lastName               String                   @db.VarChar(50)
  username               String                   @unique @db.VarChar(120)
  email                  String                   @unique @db.VarChar(120)
  password               String?
  isActive               Boolean?                 @default(true) @db.Boolean
  isVerified             Boolean?                 @default(false) @db.Boolean
  twoFactorSecret        String?
  twoFactorEnabled       Boolean?                 @default(false) @db.Boolean
  deletedAt              DateTime?                @db.Timestamp()
  createdAt              DateTime?                @default(now()) @db.Timestamp()
  updatedAt              DateTime?                @updatedAt @db.Timestamp()
  kyc                    KYC[]
  createdUsers           User[]                   @relation("userCreatedBy") // All users created by this admin
  updatedUsers           User[]                   @relation("userLastUpdatedBy") // All users updated by this admin
  tradeDispute           TradeDispute[]           @relation("moderatorTradeDispute")
  roles                  AdminAdminRole[]
  disputeAuditLog        DisputeAuditLog[]        @relation("disputeAuditLogChangedBy")
  disputePartyNote       DisputePartyNote[]       @relation("disputePartyNoteAddedBy")
  disputeEvidenceRequest DisputeEvidenceRequest[]
  userSuspensionLifted   UserSuspension[]         @relation("liftedSuspensionModerator")
  userSuspension         UserSuspension[]         @relation("suspendedModerator")
  userWarning            UserWarning[]
  userSuspensionLog      UserSuspensionLog[]
  accountReview          AccountReview[]
  smartContract          SmartContract[]
  wallets                AdminWallet[]
  refreshTokens          RefreshToken[]
  banner                 Banner[]

  @@map("admins")
}

model Block {
  id        String    @id @default(uuid())
  blocker   User      @relation("blockers", fields: [blockerId], references: [id], onDelete: Cascade, onUpdate: Cascade) // User who blocks 
  blockerId String
  blocked   User      @relation("blocked", fields: [blockedId], references: [id], onDelete: Cascade, onUpdate: Cascade) // User who is blocked
  blockedId String
  reason    String?   @db.VarChar(255)
  deletedAt DateTime? @db.Timestamp()
  createdAt DateTime? @default(now()) @db.Timestamp()
  updatedAt DateTime? @updatedAt @db.Timestamp()

  @@unique([blockerId, blockedId]) // Prevent duplicate block records
  @@map("blocks")
}

model Chat {
  id        String    @id @default(uuid())
  deletedAt DateTime? @db.Timestamp()
  createdAt DateTime? @default(now()) @db.Timestamp()
  updatedAt DateTime? @updatedAt @db.Timestamp()
  trade     Trade     @relation(fields: [tradeId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  tradeId   String    @unique

  @@map("chats")
}

model CryptocurrencyChain {
  id               String         @id @default(uuid())
  cryptocurrency   Cryptocurrency @relation("chainCryptocurrency", fields: [cryptocurrencyId], references: [id], onDelete: Cascade)
  cryptocurrencyId String
  chain            Chain          @relation("chainCryptocurrency", fields: [chainId], references: [id], onDelete: Cascade)
  chainId          String
  contractAddress  String?        @db.VarChar(200) // Contract address on this specific chain
  isVerified       Boolean        @default(false) @db.Boolean // Whether the token is verified on this chain
  createdAt        DateTime       @default(now()) @db.Timestamp()
  abiUrl           String?

  @@unique([cryptocurrencyId, chainId])
  @@map("cryptocurrency_chains")
}

model Cryptocurrency {
  id          String    @id @default(uuid())
  coingeckoId String    @unique @db.VarChar(200)
  symbol      String    @db.VarChar(200)
  name        String    @db.VarChar(200)
  image       String
  deletedAt   DateTime? @db.Timestamp()
  createdAt   DateTime? @default(now()) @db.Timestamp()
  updatedAt   DateTime? @updatedAt @db.Timestamp()

  // Relations
  chains CryptocurrencyChain[] @relation("chainCryptocurrency")
  offers Offer[]               @relation("offer")
  trades Trade[]               @relation("trade")

  @@map("cryptocurrencies")
}

enum FeedbackType {
  POSITIVE
  NEUTRAL
  NEGATIVE
}

model Feedback {
  id        String       @id @default(uuid())
  trader    User         @relation("feedbackTrader", fields: [traderId], references: [id], onUpdate: Cascade)
  traderId  String
  trade     Trade        @relation("tradeFeedback", fields: [tradeId], references: [id], onDelete: Cascade)
  tradeId   String       @unique
  message   String       @db.VarChar(256)
  type      FeedbackType
  deletedAt DateTime?    @db.Timestamp()
  createdAt DateTime?    @default(now()) @db.Timestamp()
  updatedAt DateTime?    @updatedAt @db.Timestamp()

  @@map("feedbacks")
}

model Fiat {
  id        String    @id @default(uuid())
  name      String    @db.VarChar(30)
  symbol    String    @db.VarChar(10)
  country   String    @db.VarChar(100)
  deletedAt DateTime? @db.Timestamp()
  createdAt DateTime? @default(now()) @db.Timestamp()
  updatedAt DateTime? @updatedAt @db.Timestamp()
  offers    Offer[]   @relation("offer")
  trades    Trade[]   @relation("trade")

  @@map("fiats")
}

enum KYCStatus {
  PENDING
  VERIFIED
  REJECTED
}

enum KYCDocumentType {
  ALIEN_REGISTRATION_CARD
  CITIZENSHIP_CERTIFICATE
  CONSULAR_ID_CARD
  DRIVERS_LICENSE
  FIREARMS_LICENSE
  GOVERNMENT_ISSUED_ID_CARD
  HEALTH_INSURANCE_CARD
  IMMIGRATION_DOCUMENT
  INCOME_TAX_IDENTIFICATION_DOCUMENT
  MILITARY_ID
  NATIONAL_ID_CARD
  PASSPORT
  PERMANENT_RESIDENT_CARD
  REFUGEE_TRAVEL_DOCUMENT
  RESIDENCE_PERMIT
  SOCIAL_SECURITY_CARD
  TAX_IDENTIFICATION_CARD
  VOTER_ID_CARD
  WORK_PERMIT
  OTHER
}

model UploadedFile {
  id               String           @id @default(uuid())
  key              String
  mimeType         String? // e.g., "image/jpeg"
  size             Int?
  submittedAt      DateTime         @default(now())
  documentFrontKYC KYC?             @relation("documentFront")
  documentBackKYC  KYC?             @relation("documentBack")
  selfieKYC        KYC?             @relation("selfie")
  utilityBillKYC   KYC?             @relation("utilityBill")
  bankStatementKYC KYC?             @relation("bankStatement")
  disputeEvidence  DisputeEvidence?
  deletedAt        DateTime?        @db.Timestamp()
  createdAt        DateTime?        @default(now()) @db.Timestamp()
  updatedAt        DateTime?        @updatedAt @db.Timestamp()

  @@map("uploaded_files")
}

model KYC {
  id              String          @id @default(uuid())
  userId          String          @unique
  user            User?           @relation(fields: [userId], references: [id])
  status          KYCStatus       @default(PENDING)
  rejectionReason String?         @db.Text()
  fullName        String
  dateOfBirth     DateTime        @db.Date()
  documentType    KYCDocumentType
  documentNumber  String?         @db.VarChar(100)
  additionalNotes String?         @db.Text()
  nationality     String
  documentFrontId String          @unique
  documentFront   UploadedFile    @relation("documentFront", fields: [documentFrontId], references: [id])
  documentBackId  String?         @unique
  documentBack    UploadedFile?   @relation("documentBack", fields: [documentBackId], references: [id])
  selfieId        String          @unique
  selfie          UploadedFile    @relation("selfie", fields: [selfieId], references: [id])
  utilityBillId   String?         @unique
  utilityBill     UploadedFile?   @relation("utilityBill", fields: [utilityBillId], references: [id])
  bankStatementId String?         @unique
  bankStatement   UploadedFile?   @relation("bankStatement", fields: [bankStatementId], references: [id])
  submittedAt     DateTime        @default(now()) @db.Timestamp()
  reviewedAt      DateTime?       @db.Timestamp()
  reviewedById    String?
  reviewedBy      Admin?          @relation(fields: [reviewedById], references: [id])
  deletedAt       DateTime?       @db.Timestamp()
  createdAt       DateTime?       @default(now()) @db.Timestamp()
  updatedAt       DateTime?       @updatedAt @db.Timestamp()

  @@map("kycs")
}

model Language {
  id           String         @id @default(uuid())
  name         String         @unique @db.VarChar(50)
  deletedAt    DateTime?      @db.Timestamp()
  createdAt    DateTime?      @default(now()) @db.Timestamp()
  updatedAt    DateTime?      @updatedAt @db.Timestamp()
  UserLanguage UserLanguage[]

  @@map("languages")
}

model Chain {
  id             String   @id @default(uuid())
  name           String   @unique // e.g., "Ethereum", "Polygon"
  symbol         String
  chainId        Int      @unique // Network chain ID (e.g., 1 for Ethereum mainnet)
  rpcUrl         String? // RPC endpoint URL
  explorerUrl    String? // Block explorer URL
  nativeCurrency String // Native currency symbol
  isTestnet      Boolean  @default(false) @db.Boolean
  isActive       Boolean  @default(true) @db.Boolean
  logoUrl        String? // Chain logo/icon URL
  description    String?
  createdAt      DateTime @default(now()) @db.Timestamp()
  updatedAt      DateTime @updatedAt @db.Timestamp()

  // Relations
  offers               Offer[]               @relation("offer")
  cryptocurrencyChains CryptocurrencyChain[] @relation("chainCryptocurrency")
  smartContract        SmartContract[]

  @@map("chains")
}

model Offer {
  id                String          @id @default(uuid())
  offerType         String
  pricingType       String
  listAt            Decimal         @db.Decimal(30, 10)
  limitMin          Decimal         @db.Decimal(30, 10)
  limitMax          Decimal         @db.Decimal(30, 10)
  timeLimit         Int
  tags              String[]
  label             String
  terms             String
  averageTradeSpeed Int?
  instructions      String
  kycOnly           Boolean         @default(false) @db.Boolean
  chain             Chain           @relation("offer", fields: [chainId], references: [id], onDelete: Restrict, onUpdate: Cascade)
  chainId           String
  deletedAt         DateTime?       @db.Timestamp()
  createdAt         DateTime?       @default(now()) @db.Timestamp()
  updatedAt         DateTime?       @updatedAt @db.Timestamp()
  vendor            User            @relation("offer", fields: [vendorId], references: [id], onUpdate: Cascade)
  vendorId          String
  vendorWallet      UserWallet      @relation(fields: [vendorWalletId], references: [id])
  vendorWalletId    String
  cryptocurrency    Cryptocurrency  @relation("offer", fields: [cryptocurrencyId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  cryptocurrencyId  String
  paymentMethod     PaymentMethod   @relation("offer", fields: [paymentMethodId], references: [id], onDelete: Restrict, onUpdate: Cascade)
  paymentMethodId   String
  paymentDetails    PaymentDetails? @relation("offer", fields: [paymentDetailsId], references: [id], onDelete: Restrict, onUpdate: Cascade)
  paymentDetailsId  String
  fiat              Fiat            @relation("offer", fields: [fiatId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  fiatId            String
  trades            Trade[]         @relation("tradeOffer")

  @@map("offers")
}

model PaymentMethod {
  id                      String                @id @default(uuid())
  name                    String                @db.VarChar(60)
  isRisky                 Boolean               @default(false) @db.Boolean
  deletedAt               DateTime?             @db.Timestamp()
  createdAt               DateTime?             @default(now()) @db.Timestamp()
  updatedAt               DateTime?             @updatedAt @db.Timestamp()
  paymentMethodCategory   PaymentMethodCategory @relation(fields: [paymentMethodCategoryId], references: [id], onUpdate: Cascade)
  paymentMethodCategoryId String
  offers                  Offer[]               @relation("offer")
  trades                  Trade[]
  paymentDetails          PaymentDetails[]

  @@map("payment_methods")
}

model PaymentMethodCategory {
  id             String          @id @default(uuid())
  name           String          @db.VarChar(60)
  deletedAt      DateTime?       @db.Timestamp()
  createdAt      DateTime?       @default(now()) @db.Timestamp()
  updatedAt      DateTime?       @updatedAt @db.Timestamp()
  paymentMethods PaymentMethod[]

  @@map("payment_method_categories")
}

model PaymentReceipt {
  id        String    @id @default(uuid())
  name      String    @db.VarChar(60)
  key       String
  url       String
  deletedAt DateTime? @db.Timestamp()
  createdAt DateTime? @default(now()) @db.Timestamp()
  updatedAt DateTime? @updatedAt @db.Timestamp()
  trade     Trade[]

  @@map("payment_receipts")
}

model PaymentDetails {
  id              String        @id @default(uuid())
  instructions    String
  deletedAt       DateTime?     @db.Timestamp()
  createdAt       DateTime?     @default(now()) @db.Timestamp()
  updatedAt       DateTime?     @updatedAt @db.Timestamp()
  paymentMethod   PaymentMethod @relation(fields: [paymentMethodId], references: [id], onUpdate: Cascade)
  paymentMethodId String
  offers          Offer[]       @relation("offer")
  user            User          @relation(fields: [userId], references: [id], onUpdate: Cascade)
  userId          String

  @@map("payment_details")
}

enum PremiumPurchaseStatus {
  PENDING
  COMPLETED
  FAILED
  SCHEDULED
}

enum PremiumPeriod {
  MONTHLY
  YEARLY
}

model PremiumPurchase {
  id                        String                @id @default(cuid())
  userId                    String
  payerAddress              String
  expectedAmount            Decimal               @db.Decimal(30, 10)
  status                    PremiumPurchaseStatus
  period                    PremiumPeriod
  blockchainTransactionHash String                @unique
  blockchainPaymentHash     String                @unique
  startsAt                  DateTime              @default(now())
  expiresAt                 DateTime
  deletedAt                 DateTime?             @db.Timestamp()
  createdAt                 DateTime              @default(now()) @db.Timestamp()
  updatedAt                 DateTime              @updatedAt @db.Timestamp()

  user User @relation(fields: [userId], references: [id], onUpdate: Cascade, onDelete: Cascade)

  @@unique([userId, period, status], name: "only_one_scheduled_per_period")
  @@index([userId, period, status, expiresAt])
  @@map("premium_purchases")
}

model Referral {
  id         String   @id @default(cuid())
  referrer   User     @relation("referrer", fields: [referrerId], references: [id], onDelete: Cascade)
  referrerId String
  referee    User     @relation("referee", fields: [refereeId], references: [id], onDelete: Cascade)
  refereeId  String   @unique
  createdAt  DateTime @default(now()) @db.Timestamp()

  @@index([referrerId])
  @@map("referrals")
}

enum SystemMessageType {
  TRADE_STARTED
  TRADE_COMPLETED
  TRADE_CANCELLED
  TRADE_CANCELLED_BY_MODERATOR
  TRADE_DISPUTE_OPENED
  TRADE_DISPUTE_RESOLVED
  TRADE_DISPUTE_MORE_EVIDENCES
  TRADE_EXPIRED
  TRADE_FAILED
  TRADE_NEW_MESSAGE
  NEW_LOGIN
  MAINTENANCE
  SUSPICIOUS_ACTIVITY
  PASSWORD_CHANGED
  TWO_FA_ENABLED
  TWO_FA_DISABLED
  ACCOUNT_VERIFICATION_REQUIRED
  ACCOUNT_SUSPENDED
  REVIEW_RECEIVED
  REVIEW_REMINDER
  POLICY_UPDATE
  FEATURE_ANNOUNCEMENT
  PROMOTIONAL_OFFER
  COMPLIANCE_NOTICE
  SYSTEM_ERROR
  API_DOWNTIME
  USER_WARNING
  PREMIUM_EXPIRY_WARNING
}

model SystemMessage {
  id        String            @id @default(uuid())
  type      SystemMessageType
  message   String            @db.VarChar(256)
  whenSeen  DateTime?         @db.Timestamp()
  url       String?
  deletedAt DateTime?         @db.Timestamp()
  createdAt DateTime?         @default(now()) @db.Timestamp()
  updatedAt DateTime?         @updatedAt @db.Timestamp()
  User      User              @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  userId    String

  @@map("system_messages")
}

model Tier {
  id          String  @id @default(uuid())
  name        String  @unique
  description String
  level       Int     @unique
  tradingFee  Decimal @db.Decimal(10, 8)
  discount    Decimal @db.Decimal(10, 8) // Base trading fee as a decimal (e.g., 0.001 for 0.1%)
  volume      Decimal @db.Decimal(30, 10) // Minimum trading volume to qualify for this tier
  requiredXP  Int
  users       User[]

  @@map("tiers")
}

model SmartContract {
  id                    String      @id @default(uuid())
  address               String // Deployed contract address
  chainId               String
  chain                 Chain       @relation(fields: [chainId], references: [id]) // e.g., "polygon-amoy", "mainnet"
  version               String // Optional versioning (e.g., "v1.0.0")
  deployedById          String // Admin or system user who deployed it
  deployedBy            Admin       @relation(fields: [deployedById], references: [id])
  deployerWallet        AdminWallet @relation("smartContractDeployerWallet", fields: [deployerWalletId], references: [id])
  deployerWalletId      String
  platformWallet        AdminWallet @relation("smartContractPlatformWallet", fields: [platformWalletId], references: [id])
  platformWalletId      String
  deploymentHash        String? // Transaction hash
  deploymentBlockHeight BigInt? // Transaction block height
  gasUsed               BigInt?
  gasPrice              BigInt?
  deployedAt            DateTime    @default(now()) @db.Timestamp()
  isActive              Boolean     @default(true) // Useful for versioned contracts
  artifactUrl           String
  metadata              Json? // Arbitrary extra data (tags, etc.)

  @@index([address])
  @@map("smart_contracts")
}

enum TradeStatus {
  PENDING // Trade is created but not yet confirmed  
  IN_PROGRESS // Trade is actively being processed  
  COMPLETED // Trade has been successfully completed  
  CANCELLED // Trade was cancelled by one of the parties  
  DISPUTED // Trade is under review due to a dispute  
  EXPIRED // Trade expired due to inactivity  
  FAILED // Trade failed due to an error or issue
}

model TradeEscrowDetails {
  id                        String      @id @default(uuid())
  arbitratorWallet          AdminWallet @relation(fields: [arbitratorWalletId], references: [id])
  arbitratorWalletId        String
  buyerWallet               UserWallet  @relation("buyerWalletTradeEscrowDetails", fields: [buyerWalletId], references: [id])
  buyerWalletId             String
  sellerWallet              UserWallet  @relation("sellerWalletTradeEscrowDetails", fields: [sellerWalletId], references: [id])
  sellerWalletId            String
  feeRate                   Decimal     @db.Decimal(10, 8)
  profitMargin              Decimal     @db.Decimal(10, 8)
  tradeDurationInSeconds    Int
  tradeAmount               Decimal     @db.Decimal(38, 18)
  buyerCollateral           Decimal     @db.Decimal(38, 18)
  sellerCollateral          Decimal     @db.Decimal(38, 18)
  sellerTotalFund           Decimal     @db.Decimal(38, 18)
  blockchainTradeId         String // Trade ID on the blockchain
  blockchainTransactionHash String? // Hash of the transaction on the blockchain
  trade                     Trade[]

  @@map("trade_escrow_details")
}

model Trade {
  id                        String              @id @default(uuid())
  paymentReceipt            PaymentReceipt?     @relation(fields: [paymentReceiptId], references: [id])
  paymentReceiptId          String?
  vendor                    User                @relation("vendorTrade", fields: [vendorId], references: [id])
  vendorId                  String
  vendorWallet              UserWallet?         @relation("tradeVendorWallet", fields: [vendorWalletId], references: [id])
  vendorWalletId            String?
  trader                    User                @relation("traderTrade", fields: [traderId], references: [id])
  traderId                  String
  traderWallet              UserWallet?         @relation("tradeTraderWallet", fields: [traderWalletId], references: [id])
  traderWalletId            String?
  buyer                     User                @relation("buyerTrade", fields: [buyerId], references: [id])
  buyerId                   String
  seller                    User                @relation("sellerTrade", fields: [sellerId], references: [id])
  sellerId                  String
  offer                     Offer               @relation("tradeOffer", fields: [offerId], references: [id])
  offerId                   String
  cryptocurrency            Cryptocurrency      @relation("trade", fields: [cryptocurrencyId], references: [id])
  cryptocurrencyId          String
  fiat                      Fiat                @relation("trade", fields: [fiatId], references: [id])
  fiatId                    String
  paymentMethodId           String
  paymentMethod             PaymentMethod       @relation(fields: [paymentMethodId], references: [id])
  chat                      Chat?
  cryptocurrencyAmount      Decimal             @db.Decimal(38, 18)
  fiatAmount                Decimal             @db.Decimal(30, 10)
  exchangeRate              Decimal             @db.Decimal(30, 10)
  startedAt                 DateTime            @default(now()) @db.Timestamp()
  endedAt                   DateTime?           @db.Timestamp()
  expiredAt                 DateTime?           @db.Timestamp() // Time when the trade should be considered expired
  disputedAt                DateTime?           @db.Timestamp() // Time when the trade should be considered expired
  status                    TradeStatus
  paidAt                    DateTime?           @db.Timestamp()
  fundedAt                  DateTime?           @db.Timestamp()
  vendorRejectedFunding     Boolean             @default(false) @db.Boolean
  traderRejectedFunding     Boolean             @default(false) @db.Boolean
  sellerFundedAt            DateTime?           @db.Timestamp()
  buyerFundedAt             DateTime?           @db.Timestamp()
  paymentConfirmedAt        DateTime?           @db.Timestamp()
  escrowReleasedAt          DateTime?           @db.Timestamp()
  blockchainTradeId         BigInt? // Trade ID on the blockchain
  blockchainTransactionHash String? // Hash of the transaction on the blockchain
  deletedAt                 DateTime?           @db.Timestamp()
  createdAt                 DateTime?           @default(now()) @db.Timestamp()
  updatedAt                 DateTime?           @updatedAt @db.Timestamp()
  feedback                  Feedback?           @relation("tradeFeedback")
  tradeDispute              TradeDispute?
  tradeEscrowDetailsId      String?
  tradeEscrowDetails        TradeEscrowDetails? @relation(fields: [tradeEscrowDetailsId], references: [id])

  @@map("trades")
}

model DisputePartyNote {
  id           String       @id @default(uuid())
  disputeId    String
  dispute      TradeDispute @relation("disputePartyNote", fields: [disputeId], references: [id])
  targetUserId String
  targetUser   User         @relation("disputePartyNoteTarget", fields: [targetUserId], references: [id])
  addedById    String
  addedBy      Admin        @relation("disputePartyNoteAddedBy", fields: [addedById], references: [id])
  content      String       @db.Text()
  createdAt    DateTime     @default(now()) @db.Timestamp()

  @@map("dispute_party_notes")
}

enum DisputeAction {
  STATUS_CHANGED
  EVIDENCE_REQUESTED
  MODERATOR_ASSIGNED
  DECISION_MADE
  USER_BANNED
  SYSTEM_ESCALATION
  MANUAL_ESCALATION
}

model DisputeAuditLog {
  id          String        @id @default(uuid())
  disputeId   String
  dispute     TradeDispute  @relation("disputeAuditLog", fields: [disputeId], references: [id])
  changedById String?
  changedBy   Admin?        @relation("disputeAuditLogChangedBy", fields: [changedById], references: [id])
  action      DisputeAction
  note        String?       @db.Text()
  createdAt   DateTime      @default(now()) @db.Timestamp()

  @@map("dispute_audit_logs")
}

enum EvidenceType {
  SCREENSHOT
  VIDEO
  BANK_STATEMENT
  CHAT_LOG
  PAYMENT_RECEIPT
  OTHER
}

model DisputeEvidence {
  id                     String                   @id @default(uuid())
  disputeId              String
  dispute                TradeDispute             @relation("disputeEvidences", fields: [disputeId], references: [id])
  submittedById          String
  submittedBy            User                     @relation(fields: [submittedById], references: [id])
  type                   EvidenceType
  fileId                 String?                  @unique
  file                   UploadedFile?            @relation(fields: [fileId], references: [id]) // If hosted on S3 or similar
  textContent            String?                  @db.Text()
  createdAt              DateTime                 @default(now()) @db.Timestamp()
  disputeEvidenceRequest DisputeEvidenceRequest[]

  @@map("dispute_evidences")
}

enum EvidenceRequestStatus {
  PENDING
  SUBMITTED
  DECLINED
  EXPIRED
}

model DisputeEvidenceRequest {
  id              String                @id @default(uuid())
  disputeId       String
  dispute         TradeDispute          @relation(fields: [disputeId], references: [id])
  requestedById   String
  requestedBy     Admin                 @relation(fields: [requestedById], references: [id])
  requestedFromId String
  requestedFrom   User                  @relation(fields: [requestedFromId], references: [id])
  description     String                @db.Text() // what kind of evidence is requested (e.g. proof of bank transfer)
  deadline        DateTime?             @db.Timestamp() // optional deadline to submit
  submittedAt     DateTime?             @db.Timestamp() // when the user responded
  status          EvidenceRequestStatus @default(PENDING)
  evidences       DisputeEvidence[]
  createdAt       DateTime              @default(now()) @db.Timestamp()
  updatedAt       DateTime              @updatedAt @db.Timestamp()

  @@index([disputeId, requestedFromId])
  @@map("dispute_evidence_requests")
}

enum DisputeType {
  PAYMENT_NOT_RECEIVED // Buyer claims payment was made, seller denies receipt
  PAYMENT_FRAUD // Payment originated from stolen or fraudulent sources
  CRYPTO_NOT_RELEASED // Seller refuses to release crypto after payment
  INCORRECT_PAYMENT_AMOUNT // Amount sent does not match agreed value
  PAYMENT_TO_WRONG_ACCOUNT // Payment sent to incorrect or third-party account
  FAKE_PAYMENT_PROOF // Buyer uploaded false or edited proof of payment
  LATE_PAYMENT // Buyer sent payment outside the allowed time window
  COMMUNICATION_ISSUE // Dispute caused by misunderstanding or non-responsiveness
  OFF_PLATFORM_TRANSACTION // Trade or payment occurred outside the platform
  TRADE_TIMEOUT // Trade expired without proper resolution
  ABUSIVE_BEHAVIOR // One party was abusive, threatening, or uncooperative
  IDENTITY_MISMATCH // KYC or identity verification doesn't match account info
  PLATFORM_ERROR // Technical issue caused by the platform (e.g., UI bug)
  SUSPICIOUS_ACTIVITY // Suspicious behavior detected in trade flow
  SCAM // Scamming activity
  OTHER // Miscellaneous disputes that don't fall under known types
}

enum DisputePriority {
  LOW
  MEDIUM
  HIGH
  CRITICAL
}

enum DisputeSeverity {
  LOW
  MEDIUM
  HIGH
  CRITICAL
}

enum DisputeStatus {
  OPEN
  PENDING_EVIDENCE
  INVESTIGATING
  ESCALATED
  RESOLVED
  CLOSED
}

enum DisputeResolutionType {
  RELEASE_CRYPTO // Crypto released to buyer
  REFUND_PAYMENT // Payment refunded to sender
  CANCEL_TRADE // Trade cancelled without settlement
  PARTIAL_REFUND // Partial amount refunded or settled
  SPLIT_RESOLUTION // Both parties share responsibility (e.g., 50/50)
  NO_ACTION_TAKEN // Dispute closed with no action (e.g., invalid)
  OFF_PLATFORM_DECISION // Handled outside the platform (e.g., legal process)
  PLATFORM_COMPENSATION // Platform took responsibility and compensated
}

model TradeDispute {
  id                     String                   @id @default(uuid())
  tradeId                String                   @unique
  trade                  Trade                    @relation(fields: [tradeId], references: [id])
  raisedById             String
  raisedBy               User                     @relation(fields: [raisedById], references: [id])
  type                   DisputeType
  vendorStatement        String?                  @default("") @db.Text()
  traderStatement        String?                  @default("") @db.Text()
  severity               DisputeSeverity
  status                 DisputeStatus
  resolutionNote         String?
  resolutionType         DisputeResolutionType?
  resolvedAt             DateTime?                @db.Timestamp()
  moderatorId            String?
  moderator              Admin?                   @relation("moderatorTradeDispute", fields: [moderatorId], references: [id])
  priority               DisputePriority          @default(MEDIUM)
  slaDueAt               DateTime                 @db.Timestamp() // SLA target datetime
  createdAt              DateTime                 @default(now()) @db.Timestamp()
  winnerId               String?
  winner                 User?                    @relation("wonDisputes", fields: [winnerId], references: [id])
  loserId                String?
  loser                  User?                    @relation("lostDisputes", fields: [loserId], references: [id])
  evidences              DisputeEvidence[]        @relation("disputeEvidences")
  updatedAt              DateTime                 @updatedAt @db.Timestamp()
  disputeAuditLog        DisputeAuditLog[]        @relation("disputeAuditLog")
  disputePartyNote       DisputePartyNote[]       @relation("disputePartyNote")
  disputeEvidenceRequest DisputeEvidenceRequest[]
  userSuspension         UserSuspension[]
  userWarning            UserWarning[]
  userSuspensionLog      UserSuspensionLog[]
  accountReview          AccountReview[]

  @@index([status, priority])
  @@map("trade_disputes")
}

model Trust {
  id         String    @id @default(uuid())
  truster    User      @relation("trusters", fields: [trusterId], references: [id], onDelete: Cascade, onUpdate: Cascade) // User who trusts
  trusterId  String
  trusted    User      @relation("trusted", fields: [trustedId], references: [id], onDelete: Cascade, onUpdate: Cascade) // User who is trusted
  trustedId  String
  trustLabel Int?
  deletedAt  DateTime? @db.Timestamp()
  createdAt  DateTime? @default(now()) @db.Timestamp()
  updatedAt  DateTime? @updatedAt @db.Timestamp()

  @@unique([trusterId, trustedId]) // Prevent duplicate trust records
  @@map("trusts")
}

model UserStats {
  id              String    @id @default(uuid())
  userId          String    @unique
  user            User      @relation("userStats", fields: [userId], references: [id])
  totalDisputes   Int       @default(0)
  disputesLost    Int       @default(0)
  fraudFlagged    Boolean   @default(false)
  lastDisputeDate DateTime? @db.Timestamp()

  @@map("user_stats")
}

model UserLanguage {
  user       User     @relation(fields: [userId], references: [id], onDelete: Restrict, onUpdate: Cascade)
  userId     String
  language   Language @relation(fields: [languageId], references: [id], onDelete: Restrict, onUpdate: Cascade)
  languageId String

  @@id([userId, languageId])
  @@map("user_languages")
}

model UserSuspension {
  id             String        @id @default(uuid())
  userId         String        @unique
  user           User          @relation("userSuspension", fields: [userId], references: [id])
  reason         String        @db.Text()
  initiatedAt    DateTime      @default(now()) @db.Timestamp()
  suspendedUntil DateTime?     @db.Timestamp() // null = permanent suspension
  moderatorId    String?
  moderator      Admin?        @relation("suspendedModerator", fields: [moderatorId], references: [id])
  disputeId      String?
  dispute        TradeDispute? @relation(fields: [disputeId], references: [id])
  liftedAt       DateTime?     @db.Timestamp()
  liftedById     String?
  liftedBy       Admin?        @relation("liftedSuspensionModerator", fields: [liftedById], references: [id])
  liftReason     String?

  @@map("user_suspensions")
}

model UserSuspensionLog {
  id          String        @id @default(uuid())
  userId      String
  user        User          @relation(fields: [userId], references: [id])
  action      String // e.g., "SUSPENDED", "LIFTED"
  reason      String
  moderatorId String?
  moderator   Admin?        @relation(fields: [moderatorId], references: [id])
  disputeId   String?
  dispute     TradeDispute? @relation(fields: [disputeId], references: [id])
  createdAt   DateTime      @default(now()) @db.Timestamp()

  @@map("user_suspension_logs")
}

model UserWarning {
  id               String        @id @default(uuid())
  userId           String
  user             User          @relation("userWarnings", fields: [userId], references: [id])
  message          String        @db.Text()
  createdAt        DateTime      @default(now()) @db.Timestamp()
  issuedById       String?
  issuedBy         Admin?        @relation(fields: [issuedById], references: [id])
  relatedDisputeId String?
  relatedDispute   TradeDispute? @relation(fields: [relatedDisputeId], references: [id])
  read             Boolean       @default(false)

  @@index([userId])
  @@map("user_warnings")
}

model User {
  id                     String                   @id @default(uuid())
  profileColor           String                   @db.VarChar(10)
  firstName              String                   @db.VarChar(50)
  lastName               String                   @db.VarChar(50)
  username               String                   @unique @db.VarChar(120)
  email                  String                   @unique @db.VarChar(120)
  password               String
  privateKeys            String[]                 @unique
  isVerified             Boolean?                 @default(false) @db.Boolean
  underReview            Boolean                  @default(false)
  xp                     Int                      @default(0)
  trustScore             Int                      @default(50)
  twoFactorSecret        String?
  twoFactorEnabled       Boolean?                 @default(false) @db.Boolean
  lastLoginAt            DateTime?                @db.Timestamp
  createdById            String? // Admin who created the account (Foreign key)
  createdBy              Admin?                   @relation("userCreatedBy", fields: [createdById], references: [id]) // Relation to Admin
  lastUpdatedById        String? // Admin who last updated the profile (Foreign key)
  lastUpdatedBy          Admin?                   @relation("userLastUpdatedBy", fields: [lastUpdatedById], references: [id]) // Relation to Admin
  deletedAt              DateTime?                @db.Timestamp()
  createdAt              DateTime?                @default(now()) @db.Timestamp()
  updatedAt              DateTime?                @updatedAt @db.Timestamp()
  userLanguage           UserLanguage[]
  systemMessages         SystemMessage[]
  trusters               Trust[]                  @relation("trusters")
  trusted                Trust[]                  @relation("trusted")
  blockers               Block[]                  @relation("blockers")
  blocked                Block[]                  @relation("blocked")
  offers                 Offer[]                  @relation("offer")
  feedbackTrader         Feedback[]               @relation("feedbackTrader")
  tradeVendor            Trade[]                  @relation("vendorTrade")
  tradeTrader            Trade[]                  @relation("traderTrade")
  tradeBuyer             Trade[]                  @relation("buyerTrade")
  tradeSeller            Trade[]                  @relation("sellerTrade")
  tier                   Tier?                    @relation(fields: [tierId], references: [id])
  tierId                 String?
  premiumPurchase        PremiumPurchase[]
  kyc                    KYC[]
  kycId                  String?
  referralCode           String                   @unique @default(dbgenerated("substring(md5(gen_random_uuid()::text), 1, 16)")) @db.VarChar(20)
  referrer               Referral[]               @relation("referrer")
  referre                Referral?                @relation("referee")
  paymentDetails         PaymentDetails[]
  tradeDispute           TradeDispute[]
  disputeWinner          TradeDispute[]           @relation("wonDisputes")
  disputeLoser           TradeDispute[]           @relation("lostDisputes")
  disputeEvidence        DisputeEvidence[]
  userStats              UserStats?               @relation("userStats")
  disputePartyNote       DisputePartyNote[]       @relation("disputePartyNoteTarget")
  disputeEvidenceRequest DisputeEvidenceRequest[]
  isSuspended            Boolean                  @default(false)
  suspensionId           String?
  suspension             UserSuspension?          @relation("userSuspension")
  warnings               UserWarning[]            @relation("userWarnings")
  totalWarnings          Int                      @default(0)
  userSuspensionLog      UserSuspensionLog[]
  accountReview          AccountReview[]
  wallets                UserWallet[]
  refreshTokens          RefreshToken[]

  @@index([username])
  @@map("users")
}

model AccountReview {
  id               String        @id @default(uuid())
  userId           String
  user             User          @relation(fields: [userId], references: [id])
  status           ReviewStatus  @default(PENDING)
  reason           String        @db.Text()
  reviewerId       String?
  reviewer         Admin?        @relation(fields: [reviewerId], references: [id])
  relatedDisputeId String?
  dispute          TradeDispute? @relation(fields: [relatedDisputeId], references: [id])
  createdAt        DateTime      @default(now()) @db.Timestamp()
  resolvedAt       DateTime?     @db.Timestamp()
  resolutionNote   String?

  @@index([status])
  @@map("account_reviews")
}

enum ReviewStatus {
  PENDING
  UNDER_REVIEW
  ESCALATED
  CLOSED
  ACTION_TAKEN
  NO_ACTION_NEEDED
}

model UserModerationLog {
  id              String           @id @default(uuid())
  userId          String
  action          ModerationAction
  message         String?          @db.Text()
  relatedReviewId String?
  moderatorId     String?
  timestamp       DateTime         @default(now()) @db.Timestamp()

  @@map("user_moderation_logs")
}

enum ModerationAction {
  SEND_WARNING
  SUSPEND
  ACCOUNT_REVIEW
}

model Token {
  id        String   @id @default(uuid())
  token     String
  expiresAt DateTime @db.Timestamptz
  isUsed    Boolean  @default(false) @db.Boolean

  @@unique([id, token])
  @@map("tokens")
}

model RefreshToken {
  id        String    @id @default(uuid())
  token     String    @unique
  expiresAt DateTime  @db.Timestamptz
  isUsed    Boolean   @default(false) @db.Boolean
  userId    String?
  user      User?     @relation(fields: [userId], references: [id])
  adminId   String?
  admin     Admin?    @relation(fields: [adminId], references: [id])
  createdAt DateTime? @default(now()) @db.Timestamp()
  updatedAt DateTime? @updatedAt @db.Timestamp()

  @@map("refresh_tokens")
}

enum SettingType {
  STRING
  NUMBER
  BOOLEAN
  JSON
}

model PlatformSetting {
  id           String      @id @default(uuid())
  key          String      @unique
  value        String // Store as string, convert as needed
  type         SettingType @default(STRING)
  isPrivate    Boolean     @default(true)
  canBeDeleted Boolean     @default(false)
  isEditable   Boolean     @default(true)
  createdAt    DateTime    @default(now())
  updatedAt    DateTime    @updatedAt

  @@map("platform_settings")
}

model Wallet {
  id           String        @id @default(uuid())
  address      String        @unique
  createdAt    DateTime      @default(now()) @db.Timestamp()
  userWallets  UserWallet[]
  adminWallets AdminWallet[]

  @@map("wallets")
}

model UserWallet {
  id                       String               @id @default(uuid())
  user                     User                 @relation(fields: [userId], references: [id])
  userId                   String
  wallet                   Wallet               @relation(fields: [walletId], references: [id])
  walletId                 String
  createdAt                DateTime             @default(now()) @db.Timestamp()
  offer                    Offer[]
  buyerTradeEscrowDetails  TradeEscrowDetails[] @relation("buyerWalletTradeEscrowDetails")
  sellerTradeEscrowDetails TradeEscrowDetails[] @relation("sellerWalletTradeEscrowDetails")
  vendorTrade              Trade[]              @relation("tradeVendorWallet")
  traderTrade              Trade[]              @relation("tradeTraderWallet")

  @@unique([userId, walletId])
  @@map("user_wallets")
}

model AdminWallet {
  id                          String               @id @default(uuid())
  isArbitrator                Boolean              @default(false)
  admin                       Admin                @relation(fields: [adminId], references: [id])
  adminId                     String
  wallet                      Wallet               @relation(fields: [walletId], references: [id])
  walletId                    String
  createdAt                   DateTime             @default(now()) @db.Timestamp()
  tradeEscrowDetails          TradeEscrowDetails[]
  smartContractDeployerWallet SmartContract[]      @relation("smartContractDeployerWallet")
  smartContractPlatformWallet SmartContract[]      @relation("smartContractPlatformWallet")

  @@unique([adminId, walletId])
  @@map("admin_wallets")
}

enum BannerType {
  WARNING
  NEW_FEATURE
  ANNOUNCEMENT
}

model Banner {
  id            String     @id @default(uuid())
  content       String     @db.Text
  targetWebsite String
  pages         String[]
  type          BannerType
  startDate     DateTime   @db.Timestamp()
  endDate       DateTime?  @db.Timestamp()
  isActive      Boolean    @default(true)
  publishedBy   Admin      @relation(fields: [publishedById], references: [id])
  publishedById String
  deletedAt     DateTime?  @db.Timestamp()
  createdAt     DateTime   @default(now()) @db.Timestamp()
  updatedAt     DateTime   @updatedAt @db.Timestamp()

  @@map("banners")
}
