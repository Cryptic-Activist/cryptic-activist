// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
  // output   = "node_modules/@prisma/client"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model AcceptedCryptocurrency {
  id          String @id @default(uuid())
  coingeckoId String @unique @db.VarChar(200)
  symbol      String @db.VarChar(200)
  name        String @db.VarChar(200)

  @@map("accepted_cryptocurrencies")
}

enum AdminRole {
  SUPER_ADMIN // Full access: user management, trades, disputes, KYC, settings
  SENIOR_ADMIN // Handles escalated cases and oversees other admins
  MODERATOR // Can manage trades, disputes, and users (limited control)
  KYC_REVIEWER // Only reviews and approves/rejects KYC documents
  DISPUTE_MANAGER // Handles only dispute resolution between traders
  SUPPORT_AGENT // Can respond to support queries, chat moderation
  AUDITOR // Read-only access to logs, trades, feedback, for auditing
  FINANCE_MANAGER // Views and manages fiat/crypto flow stats, premium purchases
}

model AdminRoles {
  id      String    @id @default(uuid())
  role    AdminRole
  admin   Admin     @relation(fields: [adminId], references: [id], onDelete: Cascade)
  adminId String

  @@unique([adminId, role]) // Prevent duplicate roles per admin
  @@map("admin_roles")
}

model Admin {
  id                     String                   @id @default(uuid())
  firstName              String                   @db.VarChar(50)
  lastName               String                   @db.VarChar(50)
  username               String                   @unique @db.VarChar(120)
  email                  String                   @unique @db.VarChar(120)
  password               String
  isVerified             Boolean?                 @default(false) @db.Boolean
  twoFactorSecret        String?
  twoFactorEnabled       Boolean?                 @default(false) @db.Boolean
  deletedAt              DateTime?                @db.Timestamp()
  createdAt              DateTime?                @default(now()) @db.Timestamp()
  updatedAt              DateTime?                @updatedAt @db.Timestamp()
  kyc                    KYC[]
  createdUsers           User[]                   @relation("userCreatedBy") // All users created by this admin
  updatedUsers           User[]                   @relation("userLastUpdatedBy") // All users updated by this admin
  tradeDispute           TradeDispute[]           @relation("moderatorTradeDispute")
  roles                  AdminRoles[] // Many-to-many relation to roles
  disputeAuditLog        DisputeAuditLog[]        @relation("disputeAuditLogChangedBy")
  disputePartyNote       DisputePartyNote[]       @relation("disputePartyNoteAddedBy")
  disputeEvidenceRequest DisputeEvidenceRequest[]
  userSuspensionLifted   UserSuspension[]         @relation("liftedSuspensionModerator")
  userSuspension         UserSuspension[]         @relation("suspendedModerator")
  userWarning            UserWarning[]
  userSuspensionLog      UserSuspensionLog[]
  accountReview          AccountReview[]

  @@map("admins")
}

model Block {
  id        String    @id @default(uuid())
  blocker   User      @relation("blockers", fields: [blockerId], references: [id], onDelete: Cascade, onUpdate: Cascade) // User who blocks 
  blockerId String
  blocked   User      @relation("blocked", fields: [blockedId], references: [id], onDelete: Cascade, onUpdate: Cascade) // User who is blocked
  blockedId String
  reason    String?   @db.VarChar(255)
  deletedAt DateTime? @db.Timestamp()
  createdAt DateTime? @default(now()) @db.Timestamp()
  updatedAt DateTime? @updatedAt @db.Timestamp()

  @@unique([blockerId, blockedId]) // Prevent duplicate block records
  @@map("blocks")
}

model Chat {
  id        String    @id @default(uuid())
  deletedAt DateTime? @db.Timestamp()
  createdAt DateTime? @default(now()) @db.Timestamp()
  updatedAt DateTime? @updatedAt @db.Timestamp()
  trade     Trade     @relation(fields: [tradeId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  tradeId   String    @unique

  @@map("chats")
}

model CryptocurrencyChain {
  id               String         @id @default(uuid())
  cryptocurrency   Cryptocurrency @relation("chainCryptocurrency", fields: [cryptocurrencyId], references: [id], onDelete: Cascade)
  cryptocurrencyId String
  chain            Chain          @relation("chainCryptocurrency", fields: [chainId], references: [id], onDelete: Cascade)
  chainId          String
  contractAddress  String?        @db.VarChar(200) // Contract address on this specific chain
  isVerified       Boolean        @default(false) @db.Boolean // Whether the token is verified on this chain
  createdAt        DateTime       @default(now()) @db.Timestamp()

  @@unique([cryptocurrencyId, chainId])
  @@map("cryptocurrency_chains")
}

model Cryptocurrency {
  id          String    @id @default(uuid())
  coingeckoId String    @unique @db.VarChar(200)
  symbol      String    @db.VarChar(200)
  name        String    @db.VarChar(200)
  image       String
  deletedAt   DateTime? @db.Timestamp()
  createdAt   DateTime? @default(now()) @db.Timestamp()
  updatedAt   DateTime? @updatedAt @db.Timestamp()

  // Relations
  chains CryptocurrencyChain[] @relation("chainCryptocurrency")
  offers Offer[]               @relation("offer")
  trades Trade[]               @relation("trade")

  @@map("cryptocurrencies")
}

enum FeedbackType {
  POSITIVE
  NEUTRAL
  NEGATIVE
}

model Feedback {
  id        String       @id @default(uuid())
  trader    User         @relation("feedbackTrader", fields: [traderId], references: [id], onUpdate: Cascade)
  traderId  String
  trade     Trade        @relation("tradeFeedback", fields: [tradeId], references: [id], onDelete: Cascade)
  tradeId   String       @unique
  message   String       @db.VarChar(256)
  type      FeedbackType
  deletedAt DateTime?    @db.Timestamp()
  createdAt DateTime?    @default(now()) @db.Timestamp()
  updatedAt DateTime?    @updatedAt @db.Timestamp()

  @@map("feedbacks")
}

model Fiat {
  id        String    @id @default(uuid())
  name      String    @db.VarChar(30)
  symbol    String    @db.VarChar(10)
  country   String    @db.VarChar(100)
  deletedAt DateTime? @db.Timestamp()
  createdAt DateTime? @default(now()) @db.Timestamp()
  updatedAt DateTime? @updatedAt @db.Timestamp()
  offers    Offer[]   @relation("offer")
  trades    Trade[]   @relation("trade")

  @@map("fiats")
}

enum KYCStatus {
  PENDING
  VERIFIED
  REJECTED
}

enum KYCDocumentType {
  ALIEN_REGISTRATION_CARD
  CITIZENSHIP_CERTIFICATE
  CONSULAR_ID_CARD
  DRIVERS_LICENSE
  FIREARMS_LICENSE
  GOVERNMENT_ISSUED_ID_CARD
  HEALTH_INSURANCE_CARD
  IMMIGRATION_DOCUMENT
  INCOME_TAX_IDENTIFICATION_DOCUMENT
  MILITARY_ID
  NATIONAL_ID_CARD
  PASSPORT
  PERMANENT_RESIDENT_CARD
  REFUGEE_TRAVEL_DOCUMENT
  RESIDENCE_PERMIT
  SOCIAL_SECURITY_CARD
  TAX_IDENTIFICATION_CARD
  VOTER_ID_CARD
  WORK_PERMIT
  OTHER
}

model UploadedFile {
  id               String           @id @default(uuid())
  key              String
  mimeType         String? // e.g., "image/jpeg"
  size             Int?
  submittedAt      DateTime         @default(now())
  documentFrontKYC KYC?             @relation("documentFront")
  documentBackKYC  KYC?             @relation("documentBack")
  selfieKYC        KYC?             @relation("selfie")
  utilityBillKYC   KYC?             @relation("utilityBill")
  bankStatementKYC KYC?             @relation("bankStatement")
  disputeEvidence  DisputeEvidence?
  deletedAt        DateTime?        @db.Timestamp()
  createdAt        DateTime?        @default(now()) @db.Timestamp()
  updatedAt        DateTime?        @updatedAt @db.Timestamp()

  @@map("uploaded_files")
}

model KYC {
  id              String          @id @default(uuid())
  userId          String          @unique
  user            User?           @relation(fields: [userId], references: [id])
  status          KYCStatus       @default(PENDING)
  rejectionReason String?         @db.Text()
  fullName        String
  dateOfBirth     DateTime        @db.Date()
  documentType    KYCDocumentType
  documentNumber  String?         @db.VarChar(100)
  additionalNotes String?         @db.Text()
  nationality     String
  documentFrontId String          @unique
  documentFront   UploadedFile    @relation("documentFront", fields: [documentFrontId], references: [id])
  documentBackId  String?         @unique
  documentBack    UploadedFile?   @relation("documentBack", fields: [documentBackId], references: [id])
  selfieId        String          @unique
  selfie          UploadedFile    @relation("selfie", fields: [selfieId], references: [id])
  utilityBillId   String?         @unique
  utilityBill     UploadedFile?   @relation("utilityBill", fields: [utilityBillId], references: [id])
  bankStatementId String?         @unique
  bankStatement   UploadedFile?   @relation("bankStatement", fields: [bankStatementId], references: [id])
  submittedAt     DateTime        @default(now()) @db.Timestamp()
  reviewedAt      DateTime?       @db.Timestamp()
  reviewedById    String?
  reviewedBy      Admin?          @relation(fields: [reviewedById], references: [id])
  deletedAt       DateTime?       @db.Timestamp()
  createdAt       DateTime?       @default(now()) @db.Timestamp()
  updatedAt       DateTime?       @updatedAt @db.Timestamp()

  @@map("kycs")
}

model Language {
  id           String         @id @default(uuid())
  name         String         @unique @db.VarChar(50)
  deletedAt    DateTime?      @db.Timestamp()
  createdAt    DateTime?      @default(now()) @db.Timestamp()
  updatedAt    DateTime?      @updatedAt @db.Timestamp()
  UserLanguage UserLanguage[]

  @@map("languages")
}

model Chain {
  id             String   @id @default(uuid())
  name           String   @unique // e.g., "Ethereum", "Polygon"
  symbol         String
  chainId        Int      @unique // Network chain ID (e.g., 1 for Ethereum mainnet)
  rpcUrl         String? // RPC endpoint URL
  explorerUrl    String? // Block explorer URL
  nativeCurrency String // Native currency symbol
  isTestnet      Boolean  @default(false) @db.Boolean
  isActive       Boolean  @default(true) @db.Boolean
  logoUrl        String? // Chain logo/icon URL
  description    String?
  createdAt      DateTime @default(now()) @db.Timestamp()
  updatedAt      DateTime @updatedAt @db.Timestamp()

  // Relations
  offers               Offer[]               @relation("offer")
  cryptocurrencyChains CryptocurrencyChain[] @relation("chainCryptocurrency")

  @@map("chains")
}

model Offer {
  id                  String          @id @default(uuid())
  offerType           String
  pricingType         String
  listAt              Float
  limitMin            Float
  limitMax            Float
  timeLimit           Int
  tags                String[]
  label               String
  terms               String
  averageTradeSpeed   Float?
  instructions        String
  kycOnly             Boolean         @default(false) @db.Boolean
  chain               Chain           @relation("offer", fields: [chainId], references: [id], onDelete: Restrict, onUpdate: Cascade)
  chainId             String
  deletedAt           DateTime?       @db.Timestamp()
  createdAt           DateTime?       @default(now()) @db.Timestamp()
  updatedAt           DateTime?       @updatedAt @db.Timestamp()
  vendor              User            @relation("offer", fields: [vendorId], references: [id], onUpdate: Cascade)
  vendorId            String
  vendorWalletAddress String
  cryptocurrency      Cryptocurrency  @relation("offer", fields: [cryptocurrencyId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  cryptocurrencyId    String
  paymentMethod       PaymentMethod   @relation("offer", fields: [paymentMethodId], references: [id], onDelete: Restrict, onUpdate: Cascade)
  paymentMethodId     String
  paymentDetails      PaymentDetails? @relation("offer", fields: [paymentDetailsId], references: [id], onDelete: Restrict, onUpdate: Cascade)
  paymentDetailsId    String
  fiat                Fiat            @relation("offer", fields: [fiatId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  fiatId              String
  trades              Trade[]         @relation("tradeOffer")

  @@map("offers")
}

model PaymentMethod {
  id                      String                @id @default(uuid())
  name                    String                @db.VarChar(60)
  isRisky                 Boolean               @default(false) @db.Boolean
  deletedAt               DateTime?             @db.Timestamp()
  createdAt               DateTime?             @default(now()) @db.Timestamp()
  updatedAt               DateTime?             @updatedAt @db.Timestamp()
  paymentMethodCategory   PaymentMethodCategory @relation(fields: [paymentMethodCategoryId], references: [id], onUpdate: Cascade)
  paymentMethodCategoryId String
  offers                  Offer[]               @relation("offer")
  trades                  Trade[]
  paymentDetails          PaymentDetails[]

  @@map("payment_methods")
}

model PaymentMethodCategory {
  id             String          @id @default(uuid())
  name           String          @db.VarChar(60)
  deletedAt      DateTime?       @db.Timestamp()
  createdAt      DateTime?       @default(now()) @db.Timestamp()
  updatedAt      DateTime?       @updatedAt @db.Timestamp()
  paymentMethods PaymentMethod[]

  @@map("payment_method_categories")
}

model PaymentReceipt {
  id        String    @id @default(uuid())
  name      String    @db.VarChar(60)
  key       String
  url       String
  deletedAt DateTime? @db.Timestamp()
  createdAt DateTime? @default(now()) @db.Timestamp()
  updatedAt DateTime? @updatedAt @db.Timestamp()
  trade     Trade[]

  @@map("payment_receipts")
}

model PaymentDetails {
  id              String        @id @default(uuid())
  instructions    String
  deletedAt       DateTime?     @db.Timestamp()
  createdAt       DateTime?     @default(now()) @db.Timestamp()
  updatedAt       DateTime?     @updatedAt @db.Timestamp()
  paymentMethod   PaymentMethod @relation(fields: [paymentMethodId], references: [id], onUpdate: Cascade)
  paymentMethodId String
  offers          Offer[]       @relation("offer")
  user            User          @relation(fields: [userId], references: [id], onUpdate: Cascade)
  userId          String

  @@map("payment_details")
}

model PremiumPurchase {
  id                        String    @id @default(cuid())
  depositAddress            String    @unique
  userId                    String    @unique
  user                      User      @relation(fields: [userId], references: [id], onUpdate: Cascade, onDelete: Cascade)
  expectedAmount            Float
  status                    String // e.g., "pending", "completed", "failed"
  blockchainTransactionHash String
  deletedAt                 DateTime? @db.Timestamp()
  createdAt                 DateTime? @default(now()) @db.Timestamp()
  updatedAt                 DateTime? @updatedAt @db.Timestamp()

  @@map("premium_purchases")
}

model Referral {
  id         String   @id @default(cuid())
  referrer   User     @relation("referrer", fields: [referrerId], references: [id], onDelete: Cascade)
  referrerId String
  referee    User     @relation("referee", fields: [refereeId], references: [id], onDelete: Cascade)
  refereeId  String   @unique
  createdAt  DateTime @default(now()) @db.Timestamp()

  @@index([referrerId])
  @@map("referrals")
}

enum SystemMessageType {
  TRADE_STARTED
  TRADE_COMPLETED
  TRADE_CANCELLED
  TRADE_CANCELLED_BY_MODERATOR
  TRADE_DISPUTE_OPENED
  TRADE_DISPUTE_RESOLVED
  TRADE_DISPUTE_MORE_EVIDENCES
  TRADE_EXPIRED
  TRADE_FAILED
  TRADE_NEW_MESSAGE
  NEW_LOGIN
  MAINTENANCE
  SUSPICIOUS_ACTIVITY
  PASSWORD_CHANGED
  TWO_FA_ENABLED
  TWO_FA_DISABLED
  ACCOUNT_VERIFICATION_REQUIRED
  ACCOUNT_SUSPENDED
  REVIEW_RECEIVED
  REVIEW_REMINDER
  POLICY_UPDATE
  FEATURE_ANNOUNCEMENT
  PROMOTIONAL_OFFER
  COMPLIANCE_NOTICE
  SYSTEM_ERROR
  API_DOWNTIME
  USER_WARNING
}

model SystemMessage {
  id        String            @id @default(uuid())
  type      SystemMessageType
  message   String            @db.VarChar(256)
  whenSeen  DateTime?         @db.Timestamp()
  url       String?
  deletedAt DateTime?         @db.Timestamp()
  createdAt DateTime?         @default(now()) @db.Timestamp()
  updatedAt DateTime?         @updatedAt @db.Timestamp()
  User      User              @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  userId    String

  @@map("system_messages")
}

model Tier {
  id          String @id @default(uuid())
  name        String @unique
  description String
  level       Int    @unique
  tradingFee  Float
  discount    Float // Base trading fee as a decimal (e.g., 0.001 for 0.1%)
  minVolume   Float // Minimum trading volume to qualify for this tier
  requiredXP  Int
  users       User[]

  @@map("tiers")
}

enum TradeStatus {
  PENDING // Trade is created but not yet confirmed  
  IN_PROGRESS // Trade is actively being processed  
  COMPLETED // Trade has been successfully completed  
  CANCELLED // Trade was cancelled by one of the parties  
  DISPUTED // Trade is under review due to a dispute  
  EXPIRED // Trade expired due to inactivity  
  FAILED // Trade failed due to an error or issue
}

model Trade {
  id                        String          @id @default(uuid())
  paymentReceipt            PaymentReceipt? @relation(fields: [paymentReceiptId], references: [id])
  paymentReceiptId          String?
  vendor                    User            @relation("vendorTrade", fields: [vendorId], references: [id])
  vendorId                  String
  vendorWalletAddress       String?
  trader                    User            @relation("traderTrade", fields: [traderId], references: [id])
  traderId                  String
  traderWalletAddress       String
  offer                     Offer           @relation("tradeOffer", fields: [offerId], references: [id])
  offerId                   String
  cryptocurrency            Cryptocurrency  @relation("trade", fields: [cryptocurrencyId], references: [id])
  cryptocurrencyId          String
  fiat                      Fiat            @relation("trade", fields: [fiatId], references: [id])
  fiatId                    String
  paymentMethodId           String
  paymentMethod             PaymentMethod   @relation(fields: [paymentMethodId], references: [id])
  chat                      Chat?
  cryptocurrencyAmount      Float
  fiatAmount                Float
  exchangeRate              Decimal         @db.Decimal(30, 10)
  startedAt                 DateTime        @default(now()) @db.Timestamp()
  endedAt                   DateTime?       @db.Timestamp()
  expiredAt                 DateTime?       @db.Timestamp() // Time when the trade should be considered expired
  disputedAt                DateTime?       @db.Timestamp() // Time when the trade should be considered expired
  status                    TradeStatus
  paidAt                    DateTime?       @db.Timestamp()
  fundedAt                  DateTime?       @db.Timestamp()
  paymentConfirmedAt        DateTime?       @db.Timestamp()
  escrowReleasedAt          DateTime?       @db.Timestamp()
  blockchainTradeId         BigInt? // Trade ID on the blockchain
  blockchainTransactionHash String? // Hash of the transaction on the blockchain
  deletedAt                 DateTime?       @db.Timestamp()
  createdAt                 DateTime?       @default(now()) @db.Timestamp()
  updatedAt                 DateTime?       @updatedAt @db.Timestamp()
  feedback                  Feedback?       @relation("tradeFeedback")
  tradeDispute              TradeDispute?

  @@map("trades")
}

model DisputePartyNote {
  id           String       @id @default(uuid())
  disputeId    String
  dispute      TradeDispute @relation("disputePartyNote", fields: [disputeId], references: [id])
  targetUserId String
  targetUser   User         @relation("disputePartyNoteTarget", fields: [targetUserId], references: [id])
  addedById    String
  addedBy      Admin        @relation("disputePartyNoteAddedBy", fields: [addedById], references: [id])
  content      String       @db.Text()
  createdAt    DateTime     @default(now()) @db.Timestamp()

  @@map("dispute_party_notes")
}

enum DisputeAction {
  STATUS_CHANGED
  EVIDENCE_REQUESTED
  MODERATOR_ASSIGNED
  DECISION_MADE
  USER_BANNED
  SYSTEM_ESCALATION
  MANUAL_ESCALATION
}

model DisputeAuditLog {
  id          String        @id @default(uuid())
  disputeId   String
  dispute     TradeDispute  @relation("disputeAuditLog", fields: [disputeId], references: [id])
  changedById String?
  changedBy   Admin?        @relation("disputeAuditLogChangedBy", fields: [changedById], references: [id])
  action      DisputeAction
  note        String?       @db.Text()
  createdAt   DateTime      @default(now()) @db.Timestamp()

  @@map("dispute_audit_logs")
}

enum EvidenceType {
  SCREENSHOT
  VIDEO
  BANK_STATEMENT
  CHAT_LOG
  PAYMENT_RECEIPT
  OTHER
}

model DisputeEvidence {
  id                     String                   @id @default(uuid())
  disputeId              String
  dispute                TradeDispute             @relation("disputeEvidences", fields: [disputeId], references: [id])
  submittedById          String
  submittedBy            User                     @relation(fields: [submittedById], references: [id])
  type                   EvidenceType
  fileId                 String?                  @unique
  file                   UploadedFile?            @relation(fields: [fileId], references: [id]) // If hosted on S3 or similar
  textContent            String?                  @db.Text()
  createdAt              DateTime                 @default(now()) @db.Timestamp()
  disputeEvidenceRequest DisputeEvidenceRequest[]

  @@map("dispute_evidences")
}

enum EvidenceRequestStatus {
  PENDING
  SUBMITTED
  DECLINED
  EXPIRED
}

model DisputeEvidenceRequest {
  id              String                @id @default(uuid())
  disputeId       String
  dispute         TradeDispute          @relation(fields: [disputeId], references: [id])
  requestedById   String
  requestedBy     Admin                 @relation(fields: [requestedById], references: [id])
  requestedFromId String
  requestedFrom   User                  @relation(fields: [requestedFromId], references: [id])
  description     String                @db.Text() // what kind of evidence is requested (e.g. proof of bank transfer)
  deadline        DateTime?             @db.Timestamp() // optional deadline to submit
  submittedAt     DateTime?             @db.Timestamp() // when the user responded
  status          EvidenceRequestStatus @default(PENDING)
  evidences       DisputeEvidence[]
  createdAt       DateTime              @default(now()) @db.Timestamp()
  updatedAt       DateTime              @updatedAt @db.Timestamp()

  @@index([disputeId, requestedFromId])
  @@map("dispute_evidence_requests")
}

enum DisputeType {
  PAYMENT_NOT_RECEIVED // Buyer claims payment was made, seller denies receipt
  PAYMENT_FRAUD // Payment originated from stolen or fraudulent sources
  CRYPTO_NOT_RELEASED // Seller refuses to release crypto after payment
  INCORRECT_PAYMENT_AMOUNT // Amount sent does not match agreed value
  PAYMENT_TO_WRONG_ACCOUNT // Payment sent to incorrect or third-party account
  FAKE_PAYMENT_PROOF // Buyer uploaded false or edited proof of payment
  LATE_PAYMENT // Buyer sent payment outside the allowed time window
  COMMUNICATION_ISSUE // Dispute caused by misunderstanding or non-responsiveness
  OFF_PLATFORM_TRANSACTION // Trade or payment occurred outside the platform
  TRADE_TIMEOUT // Trade expired without proper resolution
  ABUSIVE_BEHAVIOR // One party was abusive, threatening, or uncooperative
  IDENTITY_MISMATCH // KYC or identity verification doesn't match account info
  PLATFORM_ERROR // Technical issue caused by the platform (e.g., UI bug)
  SUSPICIOUS_ACTIVITY // Suspicious behavior detected in trade flow
  SCAM // Scamming activity
  OTHER // Miscellaneous disputes that don't fall under known types
}

enum DisputePriority {
  LOW
  MEDIUM
  HIGH
  CRITICAL
}

enum DisputeSeverity {
  LOW
  MEDIUM
  HIGH
  CRITICAL
}

enum DisputeStatus {
  OPEN
  PENDING_EVIDENCE
  INVESTIGATING
  ESCALATED
  RESOLVED
  CLOSED
}

enum DisputeResolutionType {
  RELEASE_CRYPTO // Crypto released to buyer
  REFUND_PAYMENT // Payment refunded to sender
  CANCEL_TRADE // Trade cancelled without settlement
  PARTIAL_REFUND // Partial amount refunded or settled
  SPLIT_RESOLUTION // Both parties share responsibility (e.g., 50/50)
  NO_ACTION_TAKEN // Dispute closed with no action (e.g., invalid)
  OFF_PLATFORM_DECISION // Handled outside the platform (e.g., legal process)
  PLATFORM_COMPENSATION // Platform took responsibility and compensated
}

model TradeDispute {
  id                     String                   @id @default(uuid())
  tradeId                String                   @unique
  trade                  Trade                    @relation(fields: [tradeId], references: [id])
  raisedById             String
  raisedBy               User                     @relation(fields: [raisedById], references: [id])
  type                   DisputeType
  vendorStatement        String?                  @default("") @db.Text()
  traderStatement        String?                  @default("") @db.Text()
  severity               DisputeSeverity
  status                 DisputeStatus
  resolutionNote         String?
  resolutionType         DisputeResolutionType?
  resolvedAt             DateTime?                @db.Timestamp()
  moderatorId            String?
  moderator              Admin?                   @relation("moderatorTradeDispute", fields: [moderatorId], references: [id])
  priority               DisputePriority          @default(MEDIUM)
  slaDueAt               DateTime                 @db.Timestamp() // SLA target datetime
  createdAt              DateTime                 @default(now()) @db.Timestamp()
  winnerId               String?
  winner                 User?                    @relation("wonDisputes", fields: [winnerId], references: [id])
  loserId                String?
  loser                  User?                    @relation("lostDisputes", fields: [loserId], references: [id])
  evidences              DisputeEvidence[]        @relation("disputeEvidences")
  updatedAt              DateTime                 @updatedAt @db.Timestamp()
  disputeAuditLog        DisputeAuditLog[]        @relation("disputeAuditLog")
  disputePartyNote       DisputePartyNote[]       @relation("disputePartyNote")
  disputeEvidenceRequest DisputeEvidenceRequest[]
  userSuspension         UserSuspension[]
  userWarning            UserWarning[]
  userSuspensionLog      UserSuspensionLog[]
  accountReview          AccountReview[]

  @@index([status, priority])
  @@map("trade_disputes")
}

model Trust {
  id         String    @id @default(uuid())
  truster    User      @relation("trusters", fields: [trusterId], references: [id], onDelete: Cascade, onUpdate: Cascade) // User who trusts
  trusterId  String
  trusted    User      @relation("trusted", fields: [trustedId], references: [id], onDelete: Cascade, onUpdate: Cascade) // User who is trusted
  trustedId  String
  trustLabel Int?
  deletedAt  DateTime? @db.Timestamp()
  createdAt  DateTime? @default(now()) @db.Timestamp()
  updatedAt  DateTime? @updatedAt @db.Timestamp()

  @@unique([trusterId, trustedId]) // Prevent duplicate trust records
  @@map("trusts")
}

model UserStats {
  id              String    @id @default(uuid())
  userId          String    @unique
  user            User      @relation("userStats", fields: [userId], references: [id])
  totalDisputes   Int       @default(0)
  disputesLost    Int       @default(0)
  fraudFlagged    Boolean   @default(false)
  lastDisputeDate DateTime? @db.Timestamp()

  @@map("user_stats")
}

model UserLanguage {
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  userId     String
  language   Language @relation(fields: [languageId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  languageId String

  @@id([userId, languageId])
  @@map("user_languages")
}

model UserSuspension {
  id             String        @id @default(uuid())
  userId         String        @unique
  user           User          @relation("userSuspension", fields: [userId], references: [id])
  reason         String        @db.Text()
  initiatedAt    DateTime      @default(now()) @db.Timestamp()
  suspendedUntil DateTime?     @db.Timestamp() // null = permanent suspension
  moderatorId    String?
  moderator      Admin?        @relation("suspendedModerator", fields: [moderatorId], references: [id])
  disputeId      String?
  dispute        TradeDispute? @relation(fields: [disputeId], references: [id])
  liftedAt       DateTime?     @db.Timestamp()
  liftedById     String?
  liftedBy       Admin?        @relation("liftedSuspensionModerator", fields: [liftedById], references: [id])
  liftReason     String?

  @@map("user_suspensions")
}

model UserSuspensionLog {
  id          String        @id @default(uuid())
  userId      String
  user        User          @relation(fields: [userId], references: [id])
  action      String // e.g., "SUSPENDED", "LIFTED"
  reason      String
  moderatorId String?
  moderator   Admin?        @relation(fields: [moderatorId], references: [id])
  disputeId   String?
  dispute     TradeDispute? @relation(fields: [disputeId], references: [id])
  createdAt   DateTime      @default(now()) @db.Timestamp()

  @@map("user_suspension_logs")
}

model UserWarning {
  id               String        @id @default(uuid())
  userId           String
  user             User          @relation("userWarnings", fields: [userId], references: [id])
  message          String        @db.Text()
  createdAt        DateTime      @default(now()) @db.Timestamp()
  issuedById       String?
  issuedBy         Admin?        @relation(fields: [issuedById], references: [id])
  relatedDisputeId String?
  relatedDispute   TradeDispute? @relation(fields: [relatedDisputeId], references: [id])
  read             Boolean       @default(false)

  @@index([userId])
  @@map("user_warnings")
}

model User {
  id                     String                   @id @default(uuid())
  profileColor           String                   @db.VarChar(10)
  firstName              String                   @db.VarChar(50)
  lastName               String                   @db.VarChar(50)
  username               String                   @unique @db.VarChar(120)
  email                  String                   @unique @db.VarChar(120)
  password               String
  privateKeys            String[]                 @unique
  isVerified             Boolean?                 @default(false) @db.Boolean
  isPremium              Boolean?
  underReview            Boolean                  @default(false)
  xp                     Int                      @default(0)
  trustScore             Int                      @default(50)
  twoFactorSecret        String?
  twoFactorEnabled       Boolean?                 @default(false) @db.Boolean
  lastLoginAt            DateTime?                @db.Timestamp
  createdById            String? // Admin who created the account (Foreign key)
  createdBy              Admin?                   @relation("userCreatedBy", fields: [createdById], references: [id]) // Relation to Admin
  lastUpdatedById        String? // Admin who last updated the profile (Foreign key)
  lastUpdatedBy          Admin?                   @relation("userLastUpdatedBy", fields: [lastUpdatedById], references: [id]) // Relation to Admin
  deletedAt              DateTime?                @db.Timestamp()
  createdAt              DateTime?                @default(now()) @db.Timestamp()
  updatedAt              DateTime?                @updatedAt @db.Timestamp()
  userLanguage           UserLanguage[]
  systemMessages         SystemMessage[]
  trusters               Trust[]                  @relation("trusters")
  trusted                Trust[]                  @relation("trusted")
  blockers               Block[]                  @relation("blockers")
  blocked                Block[]                  @relation("blocked")
  offers                 Offer[]                  @relation("offer")
  feedbackTrader         Feedback[]               @relation("feedbackTrader")
  tradeVendor            Trade[]                  @relation("vendorTrade")
  tradeTrader            Trade[]                  @relation("traderTrade")
  tier                   Tier?                    @relation(fields: [tierId], references: [id])
  tierId                 String?
  premiumPurchase        PremiumPurchase[]
  kyc                    KYC[]
  kycId                  String?
  referralCode           String                   @unique @default(dbgenerated("substring(md5(gen_random_uuid()::text), 1, 16)")) @db.VarChar(20)
  referrer               Referral[]               @relation("referrer")
  referre                Referral?                @relation("referee")
  paymentDetails         PaymentDetails[]
  tradeDispute           TradeDispute[]
  disputeWinner          TradeDispute[]           @relation("wonDisputes")
  disputeLoser           TradeDispute[]           @relation("lostDisputes")
  disputeEvidence        DisputeEvidence[]
  userStats              UserStats?               @relation("userStats")
  disputePartyNote       DisputePartyNote[]       @relation("disputePartyNoteTarget")
  disputeEvidenceRequest DisputeEvidenceRequest[]
  isSuspended            Boolean                  @default(false)
  suspensionId           String?
  suspension             UserSuspension?          @relation("userSuspension")
  warnings               UserWarning[]            @relation("userWarnings")
  totalWarnings          Int                      @default(0)
  userSuspensionLog      UserSuspensionLog[]
  accountReview          AccountReview[]

  @@index([username])
  @@map("users")
}

model AccountReview {
  id               String        @id @default(uuid())
  userId           String
  user             User          @relation(fields: [userId], references: [id])
  status           ReviewStatus  @default(PENDING)
  reason           String        @db.Text()
  reviewerId       String?
  reviewer         Admin?        @relation(fields: [reviewerId], references: [id])
  relatedDisputeId String?
  dispute          TradeDispute? @relation(fields: [relatedDisputeId], references: [id])
  createdAt        DateTime      @default(now()) @db.Timestamp()
  resolvedAt       DateTime?     @db.Timestamp()
  resolutionNote   String?

  @@index([status])
  @@map("account_reviews")
}

enum ReviewStatus {
  PENDING
  UNDER_REVIEW
  ESCALATED
  CLOSED
  ACTION_TAKEN
  NO_ACTION_NEEDED
}

model UserModerationLog {
  id              String           @id @default(uuid())
  userId          String
  action          ModerationAction
  message         String?          @db.Text()
  relatedReviewId String?
  moderatorId     String?
  timestamp       DateTime         @default(now()) @db.Timestamp()

  @@map("user_moderation_logs")
}

enum ModerationAction {
  SEND_WARNING
  SUSPEND
  ACCOUNT_REVIEW
}

model Token {
  id        String   @id @default(uuid())
  token     String
  expiresAt DateTime @db.Timestamptz
  isUsed    Boolean  @default(false) @db.Boolean

  @@unique([id, token])
  @@map("tokens")
}

enum SettingType {
  STRING
  NUMBER
  BOOLEAN
  JSON
}

model PlatformSetting {
  id        String      @id @default(uuid())
  key       String      @unique
  value     String // Store as string, convert as needed
  type      SettingType @default(STRING)
  isPrivate Boolean     @default(true)
  createdAt DateTime    @default(now())
  updatedAt DateTime    @updatedAt

  @@map("platform_settings")
}
