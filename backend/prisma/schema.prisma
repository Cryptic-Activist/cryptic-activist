// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
  // output   = "node_modules/@prisma/client"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model AcceptedCryptocurrency {
  id          String @id @default(uuid())
  coingeckoId String @unique @db.VarChar(200)
  symbol      String @db.VarChar(200)
  name        String @db.VarChar(200)

  @@map("accepted_cryptocurrencies")
}

enum AdminRole {
  SUPER_ADMIN // Full access: user management, trades, disputes, KYC, settings
  SENIOR_ADMIN // Handles escalated cases and oversees other admins
  MODERATOR // Can manage trades, disputes, and users (limited control)
  KYC_REVIEWER // Only reviews and approves/rejects KYC documents
  DISPUTE_MANAGER // Handles only dispute resolution between traders
  SUPPORT_AGENT // Can respond to support queries, chat moderation
  AUDITOR // Read-only access to logs, trades, feedback, for auditing
  FINANCE_MANAGER // Views and manages fiat/crypto flow stats, premium purchases
}

model AdminRoles {
  id      String    @id @default(uuid())
  role    AdminRole
  admin   Admin     @relation(fields: [adminId], references: [id], onDelete: Cascade)
  adminId String

  @@unique([adminId, role]) // Prevent duplicate roles per admin
  @@map("admin_roles")
}

model Admin {
  id                     String                   @id @default(uuid())
  firstName              String                   @db.VarChar(50)
  lastName               String                   @db.VarChar(50)
  username               String                   @unique @db.VarChar(120)
  email                  String                   @unique @db.VarChar(120)
  password               String
  isVerified             Boolean?                 @default(false) @db.Boolean
  twoFactorSecret        String?
  twoFactorEnabled       Boolean?                 @default(false) @db.Boolean
  deletedAt              DateTime?                @db.Timestamp()
  createdAt              DateTime?                @default(now()) @db.Timestamp()
  updatedAt              DateTime?                @updatedAt @db.Timestamp()
  kyc                    KYC[]
  createdUsers           User[]                   @relation("userCreatedBy") // All users created by this admin
  updatedUsers           User[]                   @relation("userLastUpdatedBy") // All users updated by this admin
  tradeDispute           TradeDispute[]           @relation("moderatorTradeDispute")
  roles                  AdminRoles[] // Many-to-many relation to roles
  disputeAuditLog        DisputeAuditLog[]        @relation("disputeAuditLogChangedBy")
  disputePartyNote       DisputePartyNote[]       @relation("disputePartyNoteAddedBy")
  disputeEvidenceRequest DisputeEvidenceRequest[]
  userSuspensionLifted   UserSuspension[]         @relation("liftedSuspensionModerator")
  userSuspension         UserSuspension[]         @relation("suspendedModerator")
  userWarning            UserWarning[]
  userSuspensionLog      UserSuspensionLog[]
  accountReview          AccountReview[]

  @@map("admins")
}

model Block {
  id        String    @id @default(uuid())
  blocker   User      @relation("blockers", fields: [blockerId], references: [id], onDelete: Cascade, onUpdate: Cascade) // User who blocks 
  blockerId String
  blocked   User      @relation("blocked", fields: [blockedId], references: [id], onDelete: Cascade, onUpdate: Cascade) // User who is blocked
  blockedId String
  reason    String?   @db.VarChar(255)
  deletedAt DateTime? @db.Timestamp()
  createdAt DateTime? @default(now()) @db.Timestamp()
  updatedAt DateTime? @updatedAt @db.Timestamp()

  @@unique([blockerId, blockedId]) // Prevent duplicate block records
  @@map("blocks")
}

model Chat {
  id        String    @id @default(uuid())
  deletedAt DateTime? @db.Timestamp()
  createdAt DateTime? @default(now()) @db.Timestamp()
  updatedAt DateTime? @updatedAt @db.Timestamp()
  trade     Trade     @relation(fields: [tradeId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  tradeId   String    @unique

  @@map("chats")
}

model Cryptocurrency {
  id          String    @id @default(uuid())
  coingeckoId String    @unique @db.VarChar(200)
  symbol      String    @db.VarChar(200)
  name        String    @db.VarChar(200)
  image       String
  deletedAt   DateTime? @db.Timestamp()
  createdAt   DateTime? @default(now()) @db.Timestamp()
  updatedAt   DateTime? @updatedAt @db.Timestamp()
  offers      Offer[]   @relation("offer")
  trades      Trade[]   @relation("trade")

  @@map("cryptocurrencies")
}

enum FeedbackType {
  POSITIVE
  NEUTRAL
  NEGATIVE
}

model Feedback {
  id        String       @id @default(uuid())
  trader    User         @relation("feedbackTrader", fields: [traderId], references: [id], onUpdate: Cascade)
  traderId  String
  trade     Trade        @relation("tradeFeedback", fields: [tradeId], references: [id], onDelete: Cascade)
  tradeId   String       @unique
  message   String       @db.VarChar(256)
  type      FeedbackType
  deletedAt DateTime?    @db.Timestamp()
  createdAt DateTime?    @default(now()) @db.Timestamp()
  updatedAt DateTime?    @updatedAt @db.Timestamp()

  @@map("feedbacks")
}

model Fiat {
  id        String    @id @default(uuid())
  name      String    @db.VarChar(30)
  symbol    String    @db.VarChar(10)
  country   String    @db.VarChar(100)
  deletedAt DateTime? @db.Timestamp()
  createdAt DateTime? @default(now()) @db.Timestamp()
  updatedAt DateTime? @updatedAt @db.Timestamp()
  offers    Offer[]   @relation("offer")
  trades    Trade[]   @relation("trade")

  @@map("fiats")
}

enum KYCStatus {
  PENDING
  VERIFIED
  REJECTED
}

enum KYCDocumentType {
  PASSPORT
  NATIONAL_ID
  DRIVER_LICENSE
  RESIDENCE_PERMIT
  VOTER_ID
  UTILITY_BILL
  BANK_STATEMENT
  TAX_BILL
  RENTAL_AGREEMENT
  INSURANCE_POLICY
  SELFIE
  VIDEO_VERIFICATION
  BIRTH_CERTIFICATE
  SOCIAL_SECURITY_CARD
  GOVERNMENT_LETTER
  OTHER
}

model KYC {
  id              String          @id @default(uuid())
  userId          String          @unique
  user            User            @relation(fields: [userId], references: [id])
  status          KYCStatus       @default(PENDING)
  rejectionReason String?         @db.Text()
  fullName        String
  dateOfBirth     DateTime        @db.Date()
  nationality     String
  documentType    KYCDocumentType
  documentNumber  String
  documentFront   String // S3 URL or path
  documentBack    String?
  selfie          String // S3 URL or path
  submittedAt     DateTime        @default(now()) @db.Timestamp()
  reviewedAt      DateTime?       @db.Timestamp()
  reviewedById    String?
  reviewedBy      Admin?          @relation(fields: [reviewedById], references: [id])

  @@map("kycs")
}

model Language {
  id           String         @id @default(uuid())
  name         String         @unique @db.VarChar(50)
  deletedAt    DateTime?      @db.Timestamp()
  createdAt    DateTime?      @default(now()) @db.Timestamp()
  updatedAt    DateTime?      @updatedAt @db.Timestamp()
  UserLanguage UserLanguage[]

  @@map("languages")
}

model Offer {
  id                  String          @id @default(uuid())
  offerType           String
  pricingType         String
  listAt              Float
  limitMin            Float
  limitMax            Float
  timeLimit           Int
  tags                String[]
  label               String
  terms               String
  averageTradeSpeed   Float?
  instructions        String
  deletedAt           DateTime?       @db.Timestamp()
  createdAt           DateTime?       @default(now()) @db.Timestamp()
  updatedAt           DateTime?       @updatedAt @db.Timestamp()
  vendor              User            @relation("offer", fields: [vendorId], references: [id], onUpdate: Cascade)
  vendorId            String
  vendorWalletAddress String
  cryptocurrency      Cryptocurrency  @relation("offer", fields: [cryptocurrencyId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  cryptocurrencyId    String
  paymentMethod       PaymentMethod   @relation("offer", fields: [paymentMethodId], references: [id], onDelete: Restrict, onUpdate: Cascade)
  paymentMethodId     String
  paymentDetails      PaymentDetails? @relation("offer", fields: [paymentDetailsId], references: [id], onDelete: Restrict, onUpdate: Cascade)
  paymentDetailsId    String
  fiat                Fiat            @relation("offer", fields: [fiatId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  fiatId              String
  trades              Trade[]         @relation("tradeOffer")

  @@map("offers")
}

model PaymentMethod {
  id                      String                @id @default(uuid())
  name                    String                @db.VarChar(60)
  isRisky                 Boolean               @default(false) @db.Boolean
  deletedAt               DateTime?             @db.Timestamp()
  createdAt               DateTime?             @default(now()) @db.Timestamp()
  updatedAt               DateTime?             @updatedAt @db.Timestamp()
  paymentMethodCategory   PaymentMethodCategory @relation(fields: [paymentMethodCategoryId], references: [id], onUpdate: Cascade)
  paymentMethodCategoryId String
  offers                  Offer[]               @relation("offer")
  trades                  Trade[]
  paymentDetails          PaymentDetails[]

  @@map("payment_methods")
}

model PaymentMethodCategory {
  id             String          @id @default(uuid())
  name           String          @db.VarChar(60)
  deletedAt      DateTime?       @db.Timestamp()
  createdAt      DateTime?       @default(now()) @db.Timestamp()
  updatedAt      DateTime?       @updatedAt @db.Timestamp()
  paymentMethods PaymentMethod[]

  @@map("payment_method_categories")
}

model PaymentReceipt {
  id        String    @id @default(uuid())
  name      String    @db.VarChar(60)
  key       String
  url       String
  deletedAt DateTime? @db.Timestamp()
  createdAt DateTime? @default(now()) @db.Timestamp()
  updatedAt DateTime? @updatedAt @db.Timestamp()
  trade     Trade[]

  @@map("payment_receipts")
}

model PaymentDetails {
  id              String        @id @default(uuid())
  instructions    String
  deletedAt       DateTime?     @db.Timestamp()
  createdAt       DateTime?     @default(now()) @db.Timestamp()
  updatedAt       DateTime?     @updatedAt @db.Timestamp()
  paymentMethod   PaymentMethod @relation(fields: [paymentMethodId], references: [id], onUpdate: Cascade)
  paymentMethodId String
  offers          Offer[]       @relation("offer")
  user            User          @relation(fields: [userId], references: [id], onUpdate: Cascade)
  userId          String

  @@map("payment_details")
}

model PremiumPurchase {
  id             String    @id @default(cuid())
  depositAddress String    @unique
  userId         String    @unique
  user           User      @relation(fields: [userId], references: [id], onUpdate: Cascade, onDelete: Cascade)
  expectedAmount Float
  status         String // e.g., "pending", "completed", "failed"
  transactionId  String?
  deletedAt      DateTime? @db.Timestamp()
  createdAt      DateTime? @default(now()) @db.Timestamp()
  updatedAt      DateTime? @updatedAt @db.Timestamp()

  @@map("premium_purchases")
}

model Referral {
  id         String   @id @default(cuid())
  referrer   User     @relation("referrer", fields: [referrerId], references: [id], onDelete: Cascade)
  referrerId String
  referee    User     @relation("referee", fields: [refereeId], references: [id], onDelete: Cascade)
  refereeId  String   @unique
  createdAt  DateTime @default(now()) @db.Timestamp()

  @@index([referrerId])
  @@map("referrals")
}

enum SystemMessageType {
  TRADE_STARTED
  TRADE_COMPLETED
  TRADE_CANCELLED
  TRADE_CANCELLED_BY_MODERATOR
  TRADE_DISPUTE_OPENED
  TRADE_DISPUTE_RESOLVED
  TRADE_DISPUTE_MORE_EVIDENCES
  TRADE_EXPIRED
  TRADE_FAILED
  TRADE_NEW_MESSAGE
  NEW_LOGIN
  MAINTENANCE
  SUSPICIOUS_ACTIVITY
  PASSWORD_CHANGED
  TWO_FA_ENABLED
  TWO_FA_DISABLED
  ACCOUNT_VERIFICATION_REQUIRED
  ACCOUNT_SUSPENDED
  REVIEW_RECEIVED
  REVIEW_REMINDER
  POLICY_UPDATE
  FEATURE_ANNOUNCEMENT
  PROMOTIONAL_OFFER
  COMPLIANCE_NOTICE
  SYSTEM_ERROR
  API_DOWNTIME
  USER_WARNING
}

model SystemMessage {
  id        String            @id @default(uuid())
  type      SystemMessageType
  message   String            @db.VarChar(256)
  whenSeen  DateTime?         @db.Timestamp()
  url       String?
  deletedAt DateTime?         @db.Timestamp()
  createdAt DateTime?         @default(now()) @db.Timestamp()
  updatedAt DateTime?         @updatedAt @db.Timestamp()
  User      User              @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  userId    String

  @@map("system_messages")
}

model Tier {
  id          String @id @default(uuid())
  name        String @unique
  description String
  level       Int    @unique
  tradingFee  Float
  discount    Float // Base trading fee as a decimal (e.g., 0.001 for 0.1%)
  minVolume   Float // Minimum trading volume to qualify for this tier
  requiredXP  Int
  users       User[]

  @@map("tiers")
}

enum TradeStatus {
  PENDING // Trade is created but not yet confirmed  
  IN_PROGRESS // Trade is actively being processed  
  COMPLETED // Trade has been successfully completed  
  CANCELLED // Trade was cancelled by one of the parties  
  DISPUTED // Trade is under review due to a dispute  
  EXPIRED // Trade expired due to inactivity  
  FAILED // Trade failed due to an error or issue
}

model Trade {
  id                        String          @id @default(uuid())
  paymentReceipt            PaymentReceipt? @relation(fields: [paymentReceiptId], references: [id])
  paymentReceiptId          String?
  vendor                    User            @relation("vendorTrade", fields: [vendorId], references: [id])
  vendorId                  String
  vendorWalletAddress       String?
  trader                    User            @relation("traderTrade", fields: [traderId], references: [id])
  traderId                  String
  traderWalletAddress       String
  offer                     Offer           @relation("tradeOffer", fields: [offerId], references: [id])
  offerId                   String
  cryptocurrency            Cryptocurrency  @relation("trade", fields: [cryptocurrencyId], references: [id])
  cryptocurrencyId          String
  fiat                      Fiat            @relation("trade", fields: [fiatId], references: [id])
  fiatId                    String
  paymentMethodId           String
  paymentMethod             PaymentMethod   @relation(fields: [paymentMethodId], references: [id])
  chat                      Chat?
  cryptocurrencyAmount      Float
  fiatAmount                Float
  exchangeRate              Decimal         @db.Decimal(30, 10)
  startedAt                 DateTime        @default(now()) @db.Timestamp()
  endedAt                   DateTime?       @db.Timestamp()
  expiredAt                 DateTime?       @db.Timestamp() // Time when the trade should be considered expired
  disputedAt                DateTime?       @db.Timestamp() // Time when the trade should be considered expired
  status                    TradeStatus
  paidAt                    DateTime?       @db.Timestamp()
  fundedAt                  DateTime?       @db.Timestamp()
  paymentConfirmedAt        DateTime?       @db.Timestamp()
  escrowReleasedAt          DateTime?       @db.Timestamp()
  blockchainTradeId         BigInt? // Trade ID on the blockchain
  blockchainTransactionHash String? // Hash of the transaction on the blockchain
  deletedAt                 DateTime?       @db.Timestamp()
  createdAt                 DateTime?       @default(now()) @db.Timestamp()
  updatedAt                 DateTime?       @updatedAt @db.Timestamp()
  feedback                  Feedback?       @relation("tradeFeedback")
  tradeDispute              TradeDispute?

  @@map("trades")
}

model DisputePartyNote {
  id           String       @id @default(uuid())
  disputeId    String
  dispute      TradeDispute @relation("disputePartyNote", fields: [disputeId], references: [id])
  targetUserId String
  targetUser   User         @relation("disputePartyNoteTarget", fields: [targetUserId], references: [id])
  addedById    String
  addedBy      Admin        @relation("disputePartyNoteAddedBy", fields: [addedById], references: [id])
  content      String       @db.Text()
  createdAt    DateTime     @default(now()) @db.Timestamp()

  @@map("dispute_party_notes")
}

enum DisputeAction {
  STATUS_CHANGED
  EVIDENCE_REQUESTED
  MODERATOR_ASSIGNED
  DECISION_MADE
  USER_BANNED
  SYSTEM_ESCALATION
  MANUAL_ESCALATION
}

model DisputeAuditLog {
  id          String        @id @default(uuid())
  disputeId   String
  dispute     TradeDispute  @relation("disputeAuditLog", fields: [disputeId], references: [id])
  changedById String?
  changedBy   Admin?        @relation("disputeAuditLogChangedBy", fields: [changedById], references: [id])
  action      DisputeAction
  note        String?       @db.Text()
  createdAt   DateTime      @default(now()) @db.Timestamp()

  @@map("dispute_audit_logs")
}

enum EvidenceType {
  SCREENSHOT
  VIDEO
  BANK_STATEMENT
  CHAT_LOG
  PAYMENT_RECEIPT
  OTHER
}

model DisputeEvidence {
  id                     String                   @id @default(uuid())
  disputeId              String
  dispute                TradeDispute             @relation("disputeEvidences", fields: [disputeId], references: [id])
  submittedById          String
  submittedBy            User                     @relation(fields: [submittedById], references: [id])
  type                   EvidenceType
  fileUrl                String? // If hosted on S3 or similar
  textContent            String?                  @db.Text()
  createdAt              DateTime                 @default(now()) @db.Timestamp()
  disputeEvidenceRequest DisputeEvidenceRequest[]

  @@map("dispute_evidences")
}

enum EvidenceRequestStatus {
  PENDING
  SUBMITTED
  DECLINED
  EXPIRED
}

model DisputeEvidenceRequest {
  id              String                @id @default(uuid())
  disputeId       String
  dispute         TradeDispute          @relation(fields: [disputeId], references: [id])
  requestedById   String
  requestedBy     Admin                 @relation(fields: [requestedById], references: [id])
  requestedFromId String
  requestedFrom   User                  @relation(fields: [requestedFromId], references: [id])
  description     String                @db.Text() // what kind of evidence is requested (e.g. proof of bank transfer)
  deadline        DateTime?             @db.Timestamp() // optional deadline to submit
  submittedAt     DateTime?             @db.Timestamp() // when the user responded
  status          EvidenceRequestStatus @default(PENDING)
  evidences       DisputeEvidence[]
  createdAt       DateTime              @default(now()) @db.Timestamp()
  updatedAt       DateTime              @updatedAt @db.Timestamp()

  @@index([disputeId, requestedFromId])
  @@map("dispute_evidence_requests")
}

enum DisputeType {
  PAYMENT_NOT_RECEIVED // Buyer claims payment was made, seller denies receipt
  PAYMENT_FRAUD // Payment originated from stolen or fraudulent sources
  CRYPTO_NOT_RELEASED // Seller refuses to release crypto after payment
  INCORRECT_PAYMENT_AMOUNT // Amount sent does not match agreed value
  PAYMENT_TO_WRONG_ACCOUNT // Payment sent to incorrect or third-party account
  FAKE_PAYMENT_PROOF // Buyer uploaded false or edited proof of payment
  LATE_PAYMENT // Buyer sent payment outside the allowed time window
  COMMUNICATION_ISSUE // Dispute caused by misunderstanding or non-responsiveness
  OFF_PLATFORM_TRANSACTION // Trade or payment occurred outside the platform
  TRADE_TIMEOUT // Trade expired without proper resolution
  ABUSIVE_BEHAVIOR // One party was abusive, threatening, or uncooperative
  IDENTITY_MISMATCH // KYC or identity verification doesn't match account info
  PLATFORM_ERROR // Technical issue caused by the platform (e.g., UI bug)
  SUSPICIOUS_ACTIVITY // Suspicious behavior detected in trade flow
  SCAM // Scamming activity
  OTHER // Miscellaneous disputes that don't fall under known types
}

enum DisputePriority {
  LOW
  MEDIUM
  HIGH
  CRITICAL
}

enum DisputeSeverity {
  LOW
  MEDIUM
  HIGH
  CRITICAL
}

enum DisputeStatus {
  OPEN
  PENDING_EVIDENCE
  INVESTIGATING
  ESCALATED
  RESOLVED
  CLOSED
}

enum DisputeResolutionType {
  RELEASE_CRYPTO // Crypto released to buyer
  REFUND_PAYMENT // Payment refunded to sender
  CANCEL_TRADE // Trade cancelled without settlement
  PARTIAL_REFUND // Partial amount refunded or settled
  SPLIT_RESOLUTION // Both parties share responsibility (e.g., 50/50)
  NO_ACTION_TAKEN // Dispute closed with no action (e.g., invalid)
  OFF_PLATFORM_DECISION // Handled outside the platform (e.g., legal process)
  PLATFORM_COMPENSATION // Platform took responsibility and compensated
}

model TradeDispute {
  id                     String                   @id @default(uuid())
  tradeId                String                   @unique
  trade                  Trade                    @relation(fields: [tradeId], references: [id])
  raisedById             String
  raisedBy               User                     @relation(fields: [raisedById], references: [id])
  type                   DisputeType
  vendorStatement        String?                  @default("") @db.Text()
  traderStatement        String?                  @default("") @db.Text()
  severity               DisputeSeverity
  status                 DisputeStatus
  resolutionNote         String?
  resolutionType         DisputeResolutionType?
  resolvedAt             DateTime?                @db.Timestamp()
  moderatorId            String?
  moderator              Admin?                   @relation("moderatorTradeDispute", fields: [moderatorId], references: [id])
  priority               DisputePriority          @default(MEDIUM)
  slaDueAt               DateTime                 @db.Timestamp() // SLA target datetime
  createdAt              DateTime                 @default(now()) @db.Timestamp()
  winnerId               String?
  winner                 User?                    @relation("wonDisputes", fields: [winnerId], references: [id])
  loserId                String?
  loser                  User?                    @relation("lostDisputes", fields: [loserId], references: [id])
  evidences              DisputeEvidence[]        @relation("disputeEvidences")
  updatedAt              DateTime                 @updatedAt @db.Timestamp()
  disputeAuditLog        DisputeAuditLog[]        @relation("disputeAuditLog")
  disputePartyNote       DisputePartyNote[]       @relation("disputePartyNote")
  disputeEvidenceRequest DisputeEvidenceRequest[]
  userSuspension         UserSuspension[]
  userWarning            UserWarning[]
  userSuspensionLog      UserSuspensionLog[]
  accountReview          AccountReview[]

  @@index([status, priority])
  @@map("trade_disputes")
}

enum TransactionPaymentMethodType {
  CREDIT_CARD
}

model TransactionPaymentMethod {
  id                         String                       @id @default(cuid()) // ID from the payment gateway (e.g., Stripe payment method ID)
  transactionPaymentMethodId String
  userId                     String
  user                       User                         @relation(fields: [userId], references: [id])
  type                       TransactionPaymentMethodType
  transactions               Transaction[]

  @@map("transaction_payment_method")
}

enum TransactionStatus {
  PENDING
  COMPLETED
  FAILED
}

model Transaction {
  id                         String                   @id @default(cuid())
  userId                     String
  user                       User                     @relation(fields: [userId], references: [id])
  transactionPaymentMethodId String
  transactionPaymentMethod   TransactionPaymentMethod @relation(fields: [transactionPaymentMethodId], references: [id])
  amount                     Float
  currency                   String
  status                     TransactionStatus // e.g., 'pending', 'completed', 'failed'
  gatewayTransactionId       String? // ID from the payment gateway (e.g., Stripe charge ID)
  deletedAt                  DateTime?                @db.Timestamp()
  createdAt                  DateTime?                @default(now()) @db.Timestamp()
  updatedAt                  DateTime?                @updatedAt @db.Timestamp()

  @@unique([gatewayTransactionId]) // Prevent duplicate transactions
  @@map("transactions")
}

model Trust {
  id         String    @id @default(uuid())
  truster    User      @relation("trusters", fields: [trusterId], references: [id], onDelete: Cascade, onUpdate: Cascade) // User who trusts
  trusterId  String
  trusted    User      @relation("trusted", fields: [trustedId], references: [id], onDelete: Cascade, onUpdate: Cascade) // User who is trusted
  trustedId  String
  trustLabel Int?
  deletedAt  DateTime? @db.Timestamp()
  createdAt  DateTime? @default(now()) @db.Timestamp()
  updatedAt  DateTime? @updatedAt @db.Timestamp()

  @@unique([trusterId, trustedId]) // Prevent duplicate trust records
  @@map("trusts")
}

model UserStats {
  id              String    @id @default(uuid())
  userId          String    @unique
  user            User      @relation("userStats", fields: [userId], references: [id])
  totalDisputes   Int       @default(0)
  disputesLost    Int       @default(0)
  fraudFlagged    Boolean   @default(false)
  lastDisputeDate DateTime? @db.Timestamp()

  @@map("user_stats")
}

model UserLanguage {
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  userId     String
  language   Language @relation(fields: [languageId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  languageId String

  @@id([userId, languageId])
  @@map("user_languages")
}

model UserSuspension {
  id             String        @id @default(uuid())
  userId         String        @unique
  user           User          @relation("userSuspension", fields: [userId], references: [id])
  reason         String        @db.Text()
  initiatedAt    DateTime      @default(now()) @db.Timestamp()
  suspendedUntil DateTime?     @db.Timestamp() // null = permanent suspension
  moderatorId    String?
  moderator      Admin?        @relation("suspendedModerator", fields: [moderatorId], references: [id])
  disputeId      String?
  dispute        TradeDispute? @relation(fields: [disputeId], references: [id])
  liftedAt       DateTime?     @db.Timestamp()
  liftedById     String?
  liftedBy       Admin?        @relation("liftedSuspensionModerator", fields: [liftedById], references: [id])
  liftReason     String?

  @@map("user_suspensions")
}

model UserSuspensionLog {
  id          String        @id @default(uuid())
  userId      String
  user        User          @relation(fields: [userId], references: [id])
  action      String // e.g., "SUSPENDED", "LIFTED"
  reason      String
  moderatorId String?
  moderator   Admin?        @relation(fields: [moderatorId], references: [id])
  disputeId   String?
  dispute     TradeDispute? @relation(fields: [disputeId], references: [id])
  createdAt   DateTime      @default(now()) @db.Timestamp()

  @@map("user_suspension_logs")
}

model UserWarning {
  id               String        @id @default(uuid())
  userId           String
  user             User          @relation("userWarnings", fields: [userId], references: [id])
  message          String        @db.Text()
  createdAt        DateTime      @default(now()) @db.Timestamp()
  issuedById       String?
  issuedBy         Admin?        @relation(fields: [issuedById], references: [id])
  relatedDisputeId String?
  relatedDispute   TradeDispute? @relation(fields: [relatedDisputeId], references: [id])
  read             Boolean       @default(false)

  @@index([userId])
  @@map("user_warnings")
}

model User {
  id                       String                     @id @default(uuid())
  profileColor             String                     @db.VarChar(10)
  firstName                String                     @db.VarChar(50)
  lastName                 String                     @db.VarChar(50)
  username                 String                     @unique @db.VarChar(120)
  email                    String                     @unique @db.VarChar(120)
  password                 String
  privateKeys              String[]                   @unique
  isVerified               Boolean?                   @default(false) @db.Boolean
  isPremium                Boolean?
  underReview              Boolean                    @default(false)
  xp                       Int                        @default(0)
  trustScore               Int                        @default(50)
  twoFactorSecret          String?
  twoFactorEnabled         Boolean?                   @default(false) @db.Boolean
  lastLoginAt              DateTime?                  @db.Timestamp
  createdById              String? // Admin who created the account (Foreign key)
  createdBy                Admin?                     @relation("userCreatedBy", fields: [createdById], references: [id]) // Relation to Admin
  lastUpdatedById          String? // Admin who last updated the profile (Foreign key)
  lastUpdatedBy            Admin?                     @relation("userLastUpdatedBy", fields: [lastUpdatedById], references: [id]) // Relation to Admin
  deletedAt                DateTime?                  @db.Timestamp()
  createdAt                DateTime?                  @default(now()) @db.Timestamp()
  updatedAt                DateTime?                  @updatedAt @db.Timestamp()
  userLanguage             UserLanguage[]
  systemMessages           SystemMessage[]
  trusters                 Trust[]                    @relation("trusters")
  trusted                  Trust[]                    @relation("trusted")
  blockers                 Block[]                    @relation("blockers")
  blocked                  Block[]                    @relation("blocked")
  offers                   Offer[]                    @relation("offer")
  feedbackTrader           Feedback[]                 @relation("feedbackTrader")
  tradeVendor              Trade[]                    @relation("vendorTrade")
  tradeTrader              Trade[]                    @relation("traderTrade")
  tier                     Tier?                      @relation(fields: [tierId], references: [id])
  tierId                   String?
  premiumPurchase          PremiumPurchase?
  kyc                      KYC[]
  kycId                    String?
  transactionPaymentMethod TransactionPaymentMethod[]
  transactions             Transaction[]
  referralCode             String                     @unique @default(dbgenerated("substring(md5(gen_random_uuid()::text), 1, 16)")) @db.VarChar(20)
  referrer                 Referral[]                 @relation("referrer")
  referre                  Referral?                  @relation("referee")
  paymentDetails           PaymentDetails[]
  tradeDispute             TradeDispute[]
  disputeWinner            TradeDispute[]             @relation("wonDisputes")
  disputeLoser             TradeDispute[]             @relation("lostDisputes")
  disputeEvidence          DisputeEvidence[]
  userStats                UserStats?                 @relation("userStats")
  disputePartyNote         DisputePartyNote[]         @relation("disputePartyNoteTarget")
  disputeEvidenceRequest   DisputeEvidenceRequest[]
  isSuspended              Boolean                    @default(false)
  suspensionId             String?
  suspension               UserSuspension?            @relation("userSuspension")
  warnings                 UserWarning[]              @relation("userWarnings")
  totalWarnings            Int                        @default(0)
  userSuspensionLog        UserSuspensionLog[]
  accountReview            AccountReview[]

  @@index([username])
  @@map("users")
}

model AccountReview {
  id               String        @id @default(uuid())
  userId           String
  user             User          @relation(fields: [userId], references: [id])
  status           ReviewStatus  @default(PENDING)
  reason           String        @db.Text()
  reviewerId       String?
  reviewer         Admin?        @relation(fields: [reviewerId], references: [id])
  relatedDisputeId String?
  dispute          TradeDispute? @relation(fields: [relatedDisputeId], references: [id])
  createdAt        DateTime      @default(now()) @db.Timestamp()
  resolvedAt       DateTime?     @db.Timestamp()
  resolutionNote   String?

  @@index([status])
  @@map("account_reviews")
}

enum ReviewStatus {
  PENDING
  UNDER_REVIEW
  ESCALATED
  CLOSED
  ACTION_TAKEN
  NO_ACTION_NEEDED
}

model UserModerationLog {
  id              String           @id @default(uuid())
  userId          String
  action          ModerationAction
  message         String?          @db.Text()
  relatedReviewId String?
  moderatorId     String?
  timestamp       DateTime         @default(now()) @db.Timestamp()

  @@map("user_moderation_logs")
}

enum ModerationAction {
  SEND_WARNING
  SUSPEND
  ACCOUNT_REVIEW
}

model Token {
  id        String   @id @default(uuid())
  token     String
  expiresAt DateTime @db.Timestamptz
  isUsed    Boolean  @default(false) @db.Boolean

  @@unique([id, token])
  @@map("tokens")
}
